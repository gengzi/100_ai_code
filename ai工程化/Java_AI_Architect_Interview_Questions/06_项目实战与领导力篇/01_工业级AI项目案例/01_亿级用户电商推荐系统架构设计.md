# 亿级用户电商推荐系统架构设计

## 题目1: ⭐⭐⭐⭐⭐ 电商推荐系统的整体架构设计与技术选型

**问题描述**:
设计一个支撑亿级用户的电商推荐系统，要求具备高可用性、高并发处理能力、实时推荐和离线训练能力。请从架构设计、技术选型、数据流处理、模型训练和部署等多个维度进行详细设计。

**答案要点**:
- **分层架构**: 数据层、计算层、服务层、应用层
- **技术选型**: 大数据生态、AI框架、消息队列、缓存系统
- **数据处理**: 实时流处理、批处理、特征工程
- **模型架构**: 多模型融合、冷启动处理、A/B测试
- **性能优化**: 缓存策略、并发控制、资源调度

**代码示例**:
```java
// 推荐系统整体架构
@SpringBootApplication
@EnableEurekaClient
@EnableAsync
@EnableScheduling
public class RecommendationSystemApplication {
    public static void main(String[] args) {
        SpringApplication.run(RecommendationSystemApplication.class, args);
    }

    @Bean
    public ThreadPoolTaskExecutor recommendationExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(20);
        executor.setMaxPoolSize(50);
        executor.setQueueCapacity(1000);
        executor.setThreadNamePrefix("recommendation-");
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        executor.initialize();
        return executor;
    }
}

// 推荐服务主控制器
@RestController
@RequestMapping("/api/recommendation")
@Slf4j
public class RecommendationController {

    private final RecommendationService recommendationService;
    private final UserProfileService userProfileService;
    private final MetricsCollector metricsCollector;
    private final Tracer tracer;

    public RecommendationController(RecommendationService recommendationService,
                                  UserProfileService userProfileService,
                                  MetricsCollector metricsCollector,
                                  Tracer tracer) {
        this.recommendationService = recommendationService;
        this.userProfileService = userProfileService;
        this.metricsCollector = metricsCollector;
        this.tracer = tracer;
    }

    @GetMapping("/user/{userId}/home")
    public ResponseEntity<RecommendationResponse> getHomeRecommendations(
            @PathVariable String userId,
            @RequestParam(defaultValue = "20") int limit,
            HttpServletRequest request) {

        Span span = tracer.nextSpan().name("home-recommendation");
        try (Tracer.SpanInScope ws = tracer.withSpanInScope(span)) {
            span.tag("user.id", userId);
            span.tag("recommendation.type", "home");
            span.tag("limit", String.valueOf(limit));

            long startTime = System.currentTimeMillis();

            try {
                // 获取用户画像
                UserProfile userProfile = userProfileService.getUserProfile(userId);

                // 获取推荐结果
                RecommendationResponse response = recommendationService.getHomeRecommendations(
                    userId, userProfile, limit
                );

                // 记录推荐指标
                metricsCollector.recordRecommendation("home", userId, response.getItems().size(),
                    System.currentTimeMillis() - startTime);

                span.tag("result.count", String.valueOf(response.getItems().size()));
                span.tag("result.success", "true");

                return ResponseEntity.ok(response);

            } catch (Exception e) {
                span.tag("error", e.getMessage());
                metricsCollector.recordRecommendationError("home", userId, e);
                return ResponseEntity.ok(RecommendationResponse.empty());
            }

        } finally {
            span.end();
        }
    }

    @GetMapping("/user/{userId}/product/{productId}/related")
    public ResponseEntity<RecommendationResponse> getRelatedProductRecommendations(
            @PathVariable String userId,
            @PathVariable String productId,
            @RequestParam(defaultValue = "10") int limit) {

        return handleRecommendationRequest("related-product", () ->
            recommendationService.getRelatedProductRecommendations(userId, productId, limit));
    }

    @GetMapping("/user/{userId}/cart/recommend")
    public ResponseEntity<RecommendationResponse> getCartRecommendations(
            @PathVariable String userId,
            @RequestParam(defaultValue = "15") int limit) {

        return handleRecommendationRequest("cart", () ->
            recommendationService.getCartRecommendations(userId, limit));
    }

    @GetMapping("/user/{userId}/search/{query}")
    public ResponseEntity<RecommendationResponse> getSearchRecommendations(
            @PathVariable String userId,
            @PathVariable String query,
            @RequestParam(defaultValue = "20") int limit) {

        return handleRecommendationRequest("search", () ->
            recommendationService.getSearchRecommendations(userId, query, limit));
    }

    @PostMapping("/user/{userId}/feedback")
    public ResponseEntity<Void> recordUserFeedback(
            @PathVariable String userId,
            @RequestBody UserFeedbackRequest feedback) {

        try {
            recommendationService.recordUserFeedback(userId, feedback);
            metricsCollector.recordUserFeedback(userId, feedback.getType());
            return ResponseEntity.ok().build();

        } catch (Exception e) {
            log.error("用户反馈记录失败: userId={}, feedback={}", userId, feedback, e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    private ResponseEntity<RecommendationResponse> handleRecommendationRequest(
            String type, Supplier<RecommendationResponse> recommendationSupplier) {

        Span span = tracer.nextSpan().name("recommendation-" + type);
        try (Tracer.SpanInScope ws = tracer.withSpanInScope(span)) {
            span.tag("recommendation.type", type);

            RecommendationResponse response = recommendationSupplier.get();

            if (response != null && !response.getItems().isEmpty()) {
                span.tag("result.count", String.valueOf(response.getItems().size()));
                span.tag("result.success", "true");
                return ResponseEntity.ok(response);
            } else {
                span.tag("result.success", "false");
                return ResponseEntity.ok(RecommendationResponse.empty());
            }

        } catch (Exception e) {
            span.tag("error", e.getMessage());
            log.error("推荐请求处理失败: type={}", type, e);
            return ResponseEntity.ok(RecommendationResponse.empty());
        } finally {
            span.end();
        }
    }
}

// 推荐服务核心实现
@Service
@Slf4j
public class RecommendationService {

    private final UserProfileService userProfileService;
    private final ModelInferenceService modelInferenceService;
    private final CandidateGenerator candidateGenerator;
    private final RankingService rankingService;
    private final DiversityService diversityService;
    private final FeedbackService feedbackService;
    private final CacheManager cacheManager;
    private final MetricsCollector metricsCollector;

    public RecommendationService(UserProfileService userProfileService,
                                ModelInferenceService modelInferenceService,
                                CandidateGenerator candidateGenerator,
                                RankingService rankingService,
                                DiversityService diversityService,
                                FeedbackService feedbackService,
                                CacheManager cacheManager,
                                MetricsCollector metricsCollector) {
        this.userProfileService = userProfileService;
        this.modelInferenceService = modelInferenceService;
        this.candidateGenerator = candidateGenerator;
        this.rankingService = rankingService;
        this.diversityService = diversityService;
        this.feedbackService = feedbackService;
        this.cacheManager = cacheManager;
        this.metricsCollector = metricsCollector;
    }

    @Cacheable(value = "home_recommendations", key = "#userId + '_' + #limit")
    public RecommendationResponse getHomeRecommendations(String userId,
                                                        UserProfile userProfile,
                                                        int limit) {
        log.info("获取首页推荐: userId={}, limit={}", userId, limit);

        try {
            // 1. 冷启动处理
            if (userProfile.isColdStart()) {
                return handleColdStartRecommendation(userId, limit);
            }

            // 2. 多路候选生成
            List<RecommendationCandidate> candidates = generateCandidates(userProfile);

            log.info("候选商品生成完成: userId={}, candidateCount={}", userId, candidates.size());

            if (candidates.isEmpty()) {
                return RecommendationResponse.empty();
            }

            // 3. 特征提取和模型推理
            List<RankedItem> rankedItems = rankCandidates(userProfile, candidates);

            // 4. 多样性处理
            List<RecommendationItem> finalItems = applyDiversityFiltering(rankedItems, limit);

            // 5. 结果封装
            RecommendationResponse response = RecommendationResponse.builder()
                .userId(userId)
                .scenario("home")
                .items(finalItems)
                .generateTime(LocalDateTime.now())
                .algorithmVersion(getCurrentAlgorithmVersion())
                .build();

            // 6. 异步记录推荐日志
            CompletableFuture.runAsync(() -> recordRecommendationLog(userId, response));

            return response;

        } catch (Exception e) {
            log.error("首页推荐生成失败: userId={}", userId, e);
            return RecommendationResponse.empty();
        }
    }

    private RecommendationResponse handleColdStartRecommendation(String userId, int limit) {
        log.info("冷启动用户推荐: userId={}", userId);

        // 1. 基于热门商品推荐
        List<RecommendationItem> hotItems = getHotItems(limit / 2);

        // 2. 基于地域推荐
        List<RecommendationItem> locationItems = getLocationBasedItems(userId, limit / 2);

        // 3. 合并结果
        List<RecommendationItem> items = new ArrayList<>();
        items.addAll(hotItems);
        items.addAll(locationItems);

        // 4. 限制数量
        items = items.stream()
            .limit(limit)
            .collect(Collectors.toList());

        return RecommendationResponse.builder()
            .userId(userId)
            .scenario("home")
            .items(items)
            .generateTime(LocalDateTime.now())
            .algorithmVersion("cold_start_v1")
            .coldStart(true)
            .build();
    }

    private List<RecommendationCandidate> generateCandidates(UserProfile userProfile) {
        List<RecommendationCandidate> allCandidates = new ArrayList<>();

        // 1. 协同过滤候选
        List<RecommendationCandidate> cfCandidates = candidateGenerator.generateCFCandidates(
            userProfile, 500
        );
        allCandidates.addAll(cfCandidates);

        // 2. 基于内容的候选
        List<RecommendationCandidate> contentCandidates = candidateGenerator.generateContentCandidates(
            userProfile, 300
        );
        allCandidates.addAll(contentCandidates);

        // 3. 基于用户行为的候选
        List<RecommendationCandidate> behaviorCandidates = candidateGenerator.generateBehaviorCandidates(
            userProfile, 200
        );
        allCandidates.addAll(behaviorCandidates);

        // 4. 社交网络候选
        List<RecommendationCandidate> socialCandidates = candidateGenerator.generateSocialCandidates(
            userProfile, 100
        );
        allCandidates.addAll(socialCandidates);

        // 5. 去重和过滤
        return deduplicateCandidates(allCandidates);
    }

    private List<RecommendationCandidate> deduplicateCandidates(
            List<RecommendationCandidate> candidates) {

        Map<String, RecommendationCandidate> uniqueCandidates = new HashMap<>();

        for (RecommendationCandidate candidate : candidates) {
            String itemId = candidate.getItemId();
            RecommendationCandidate existing = uniqueCandidates.get(itemId);

            if (existing == null || candidate.getScore() > existing.getScore()) {
                uniqueCandidates.put(itemId, candidate);
            }
        }

        return new ArrayList<>(uniqueCandidates.values());
    }

    private List<RankedItem> rankCandidates(UserProfile userProfile,
                                           List<RecommendationCandidate> candidates) {
        long startTime = System.currentTimeMillis();

        try {
            // 1. 批量特征提取
            List<FeatureVector> features = extractFeatures(userProfile, candidates);

            // 2. 模型推理
            List<RankingScore> scores = modelInferenceService.batchRank(
                userProfile.getUserFeatures(), features
            );

            // 3. 结果合并和排序
            List<RankedItem> rankedItems = new ArrayList<>();
            for (int i = 0; i < candidates.size(); i++) {
                RecommendationCandidate candidate = candidates.get(i);
                RankingScore score = scores.get(i);

                RankedItem rankedItem = RankedItem.builder()
                    .itemId(candidate.getItemId())
                    .finalScore(score.getScore())
                    .features(score.getFeatures())
                    .explanation(score.getExplanation())
                    .build();

                rankedItems.add(rankedItem);
            }

            // 4. 按分数排序
            rankedItems.sort((a, b) -> Double.compare(b.getFinalScore(), a.getFinalScore()));

            long duration = System.currentTimeMillis() - startTime;
            metricsCollector.recordRankingPerformance(rankedItems.size(), duration);

            return rankedItems;

        } catch (Exception e) {
            log.error("候选商品排序失败: userProfile={}, candidateCount={}",
                     userProfile.getUserId(), candidates.size(), e);
            return Collections.emptyList();
        }
    }

    private List<FeatureVector> extractFeatures(UserProfile userProfile,
                                               List<RecommendationCandidate> candidates) {
        return candidates.parallelStream()
            .map(candidate -> {
                try {
                    FeatureExtractor extractor = new FeatureExtractor(userProfile, candidate);
                    return extractor.extract();
                } catch (Exception e) {
                    log.error("特征提取失败: itemId={}", candidate.getItemId(), e);
                    return FeatureVector.empty();
                }
            })
            .collect(Collectors.toList());
    }

    private List<RecommendationItem> applyDiversityFiltering(List<RankedItem> rankedItems,
                                                           int limit) {
        if (rankedItems.isEmpty()) {
            return Collections.emptyList();
        }

        try {
            // 1. 多样性算法
            List<RankedItem> diversifiedItems = diversityService.applyDiversity(
                rankedItems, limit * 2 // 先选出2倍的数量
            );

            // 2. 规则过滤
            List<RankedItem> filteredItems = applyBusinessRules(diversifiedItems);

            // 3. 最终截断
            return filteredItems.stream()
                .limit(limit)
                .map(this::convertToRecommendationItem)
                .collect(Collectors.toList());

        } catch (Exception e) {
            log.error("多样性过滤失败，使用降级策略", e);
            // 降级策略：直接取前N个
            return rankedItems.stream()
                .limit(limit)
                .map(this::convertToRecommendationItem)
                .collect(Collectors.toList());
        }
    }

    private List<RankedItem> applyBusinessRules(List<RankedItem> items) {
        return items.stream()
            .filter(item -> {
                // 业务规则过滤
                return item.getFinalScore() > 0.1 && // 分数阈值
                       !isBlacklisted(item.getItemId()) && // 黑名单过滤
                       isInStock(item.getItemId()); // 库存检查
            })
            .collect(Collectors.toList());
    }

    private RecommendationItem convertToRecommendationItem(RankedItem rankedItem) {
        return RecommendationItem.builder()
            .itemId(rankedItem.getItemId())
            .score(rankedItem.getFinalScore())
            .reason(rankedItem.getExplanation())
            .timestamp(LocalDateTime.now())
            .build();
    }

    private boolean isBlacklisted(String itemId) {
        // 检查商品是否在黑名单中
        return false; // 简化实现
    }

    private boolean isInStock(String itemId) {
        // 检查商品是否有库存
        return true; // 简化实现
    }

    private List<RecommendationItem> getHotItems(int limit) {
        // 获取热门商品
        return Collections.emptyList(); // 简化实现
    }

    private List<RecommendationItem> getLocationBasedItems(String userId, int limit) {
        // 基于地域的推荐
        return Collections.emptyList(); // 简化实现
    }

    private String getCurrentAlgorithmVersion() {
        return "v2.1.0";
    }

    private void recordRecommendationLog(String userId, RecommendationResponse response) {
        try {
            RecommendationLog log = RecommendationLog.builder()
                .userId(userId)
                .scenario(response.getScenario())
                .itemIds(response.getItems().stream()
                    .map(RecommendationItem::getItemId)
                    .collect(Collectors.toList()))
                .algorithmVersion(response.getAlgorithmVersion())
                .generateTime(response.getGenerateTime())
                .build();

            // 异步写入日志存储
            feedbackService.recordRecommendationLog(log);

        } catch (Exception e) {
            log.error("推荐日志记录失败: userId={}", userId, e);
        }
    }

    public RecommendationResponse getRelatedProductRecommendations(String userId,
                                                                 String productId,
                                                                 int limit) {
        // 相关商品推荐实现
        return RecommendationResponse.empty();
    }

    public RecommendationResponse getCartRecommendations(String userId, int limit) {
        // 购物车推荐实现
        return RecommendationResponse.empty();
    }

    public RecommendationResponse getSearchRecommendations(String userId, String query, int limit) {
        // 搜索推荐实现
        return RecommendationResponse.empty();
    }

    public void recordUserFeedback(String userId, UserFeedbackRequest feedback) {
        // 用户反馈记录实现
    }
}

// 候选生成器
@Service
@Slf4j
public class CandidateGenerator {

    private final CFService cfService;
    private final ContentBasedService contentBasedService;
    private final UserBehaviorService behaviorService;
    private final SocialNetworkService socialNetworkService;
    private final ItemService itemService;

    public CandidateGenerator(CFService cfService,
                             ContentBasedService contentBasedService,
                             UserBehaviorService behaviorService,
                             SocialNetworkService socialNetworkService,
                             ItemService itemService) {
        this.cfService = cfService;
        this.contentBasedService = contentBasedService;
        this.behaviorService = behaviorService;
        this.socialNetworkService = socialNetworkService;
        this.itemService = itemService;
    }

    public List<RecommendationCandidate> generateCFCandidates(UserProfile userProfile, int limit) {
        try {
            List<String> itemIds = cfService.getCollaborativeFilteringRecommendations(
                userProfile.getUserId(), limit
            );

            return itemIds.stream()
                .map(itemId -> RecommendationCandidate.builder()
                    .itemId(itemId)
                    .source("CF")
                    .score(0.8) // 初始分数
                    .build())
                .collect(Collectors.toList());

        } catch (Exception e) {
            log.error("协同过滤候选生成失败: userId={}", userProfile.getUserId(), e);
            return Collections.emptyList();
        }
    }

    public List<RecommendationCandidate> generateContentCandidates(UserProfile userProfile, int limit) {
        try {
            List<String> preferredCategories = userProfile.getPreferredCategories();
            List<String> itemIds = contentBasedService.getContentBasedRecommendations(
                preferredCategories, limit
            );

            return itemIds.stream()
                .map(itemId -> RecommendationCandidate.builder()
                    .itemId(itemId)
                    .source("CONTENT")
                    .score(0.7)
                    .build())
                .collect(Collectors.toList());

        } catch (Exception e) {
            log.error("基于内容候选生成失败: userId={}", userProfile.getUserId(), e);
            return Collections.emptyList();
        }
    }

    public List<RecommendationCandidate> generateBehaviorCandidates(UserProfile userProfile, int limit) {
        try {
            List<String> itemIds = behaviorService.getBehaviorBasedRecommendations(
                userProfile.getUserId(), userProfile.getRecentBehaviors(), limit
            );

            return itemIds.stream()
                .map(itemId -> RecommendationCandidate.builder()
                    .itemId(itemId)
                    .source("BEHAVIOR")
                    .score(0.6)
                    .build())
                .collect(Collectors.toList());

        } catch (Exception e) {
            log.error("基于行为候选生成失败: userId={}", userProfile.getUserId(), e);
            return Collections.emptyList();
        }
    }

    public List<RecommendationCandidate> generateSocialCandidates(UserProfile userProfile, int limit) {
        try {
            List<String> friendIds = userProfile.getFriendIds();
            List<String> itemIds = socialNetworkService.getSocialRecommendations(
                friendIds, limit
            );

            return itemIds.stream()
                .map(itemId -> RecommendationCandidate.builder()
                    .itemId(itemId)
                    .source("SOCIAL")
                    .score(0.5)
                    .build())
                .collect(Collectors.toList());

        } catch (Exception e) {
            log.error("社交网络候选生成失败: userId={}", userProfile.getUserId(), e);
            return Collections.emptyList();
        }
    }
}

// 特征提取器
@Component
@Slf4j
public class FeatureExtractor {

    private static final int FEATURE_DIMENSION = 256;

    public FeatureVector extract(UserProfile userProfile, RecommendationCandidate candidate) {
        try {
            float[] features = new float[FEATURE_DIMENSION];
            int featureIndex = 0;

            // 1. 用户特征 (64维)
            float[] userFeatures = extractUserFeatures(userProfile);
            System.arraycopy(userFeatures, 0, features, featureIndex, userFeatures.length);
            featureIndex += userFeatures.length;

            // 2. 商品特征 (128维)
            float[] itemFeatures = extractItemFeatures(candidate.getItemId());
            System.arraycopy(itemFeatures, 0, features, featureIndex, itemFeatures.length);
            featureIndex += itemFeatures.length;

            // 3. 上下文特征 (32维)
            float[] contextFeatures = extractContextFeatures(userProfile, candidate);
            System.arraycopy(contextFeatures, 0, features, featureIndex, contextFeatures.length);
            featureIndex += contextFeatures.length;

            // 4. 交互特征 (32维)
            float[] interactionFeatures = extractInteractionFeatures(userProfile, candidate);
            System.arraycopy(interactionFeatures, 0, features, featureIndex, interactionFeatures.length);

            return new FeatureVector(features);

        } catch (Exception e) {
            log.error("特征提取失败: userId={}, itemId={}", userProfile.getUserId(), candidate.getItemId(), e);
            return FeatureVector.random(FEATURE_DIMENSION);
        }
    }

    private float[] extractUserFeatures(UserProfile userProfile) {
        float[] features = new float[64];
        int index = 0;

        // 人口统计特征 (16维)
        features[index++] = normalizeAge(userProfile.getAge());
        features[index++] = encodeGender(userProfile.getGender());
        features[index++] = encodeIncome(userProfile.getIncome());
        // ... 其他人口统计特征

        // 兴趣偏好特征 (32维)
        List<Float> interests = userProfile.getInterestVector();
        for (int i = 0; i < Math.min(interests.size(), 32); i++) {
            features[index++] = interests.get(i);
        }

        // 行为特征 (16维)
        features[index++] = normalizePurchaseFrequency(userProfile.getPurchaseFrequency());
        features[index++] = normalizeAvgOrderValue(userProfile.getAvgOrderValue());
        // ... 其他行为特征

        return features;
    }

    private float[] extractItemFeatures(String itemId) {
        float[] features = new float[128];
        int index = 0;

        // 商品基础特征 (32维)
        ItemInfo itemInfo = getItemInfo(itemId);
        features[index++] = encodeCategory(itemInfo.getCategory());
        features[index++] = encodeBrand(itemInfo.getBrand());
        features[index++] = normalizePrice(itemInfo.getPrice());
        // ... 其他基础特征

        // 商品嵌入特征 (96维)
        float[] embedding = getItemEmbedding(itemId);
        System.arraycopy(embedding, 0, features, index, Math.min(embedding.length, 96));

        return features;
    }

    private float[] extractContextFeatures(UserProfile userProfile, RecommendationCandidate candidate) {
        float[] features = new float[32];
        int index = 0;

        // 时间特征 (8维)
        LocalDateTime now = LocalDateTime.now();
        features[index++] = encodeHour(now.getHour());
        features[index++] = encodeDayOfWeek(now.getDayOfWeek().getValue());
        features[index++] = encodeSeason(now.getMonthValue());
        // ... 其他时间特征

        // 地理特征 (8维)
        String location = userProfile.getLocation();
        features[index++] = encodeRegion(location);
        // ... 其他地理特征

        // 会话特征 (16维)
        // 会话时长、页面浏览数等

        return features;
    }

    private float[] extractInteractionFeatures(UserProfile userProfile, RecommendationCandidate candidate) {
        float[] features = new float[32];
        int index = 0;

        // 历史交互特征
        List<UserBehavior> behaviors = userProfile.getRecentBehaviors();
        features[index++] = calculateViewCount(behaviors, candidate.getItemId());
        features[index++] = calculateClickRate(behaviors, candidate.getItemId());
        features[index++] = calculatePurchaseRate(behaviors, candidate.getItemId());
        // ... 其他交互特征

        return features;
    }

    // 特征编码和归一化方法
    private float normalizeAge(int age) {
        return Math.min(1.0f, age / 100.0f);
    }

    private float encodeGender(String gender) {
        switch (gender.toLowerCase()) {
            case "male": return 0.0f;
            case "female": return 1.0f;
            default: return 0.5f;
        }
    }

    private float normalizePrice(double price) {
        return (float) Math.log1p(price) / 20.0f; // log归一化
    }

    private ItemInfo getItemInfo(String itemId) {
        // 从商品服务获取商品信息
        return new ItemInfo(); // 简化实现
    }

    private float[] getItemEmbedding(String itemId) {
        // 从嵌入服务获取商品嵌入
        return new float[96]; // 简化实现
    }
}
```

---

## 题目2: ⭐⭐⭐⭐ 推荐系统的实时数据流处理架构

**问题描述**:
亿级用户电商推荐系统需要处理海量的实时数据流，包括用户行为数据、商品数据、交易数据等。请设计一个基于Flink和Kafka的实时数据处理架构，实现实时特征更新、模型在线学习和实时推荐。

**答案要点**:
- **流处理架构**: Kafka + Flink + Redis + ClickHouse
- **实时特征工程**: 实时用户画像、商品特征计算
- **在线学习**: 实时模型训练和参数更新
- **实时推荐**: 毫秒级推荐响应
- **监控告警**: 实时数据质量监控和异常检测

**代码示例**:
```java
// 实时数据处理主架构
@SpringBootApplication
@EnableStreaming
public class RealTimeDataProcessingApplication {
    public static void main(String[] args) {
        SpringApplication.run(RealTimeDataProcessingApplication.class, args);
    }

    @Bean
    public FlinkKafkaConsumer<String> behaviorEventConsumer() {
        Properties properties = new Properties();
        properties.setProperty("bootstrap.servers", "kafka:9092");
        properties.setProperty("group.id", "behavior-processor");
        return new FlinkKafkaConsumer<>(
            Arrays.asList("user-behavior", "purchase-events", "item-events"),
            new BehaviorEventDeserializer(),
            properties
        );
    }

    @Bean
    public StreamExecutionEnvironment createExecutionEnvironment() {
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        env.setParallelism(12);
        env.enableCheckpointing(60000); // 1分钟checkpoint间隔
        return env;
    }
}

// 实时用户行为处理作业
@Component
@Slf4j
public class RealTimeBehaviorProcessingJob {

    private final UserProfileService userProfileService;
    private final RealTimeFeatureService featureService;
    private final ModelUpdateService modelUpdateService;
    private final RecommendationCache recommendationCache;
    private final MetricsCollector metricsCollector;

    public RealTimeBehaviorProcessingJob(UserProfileService userProfileService,
                                        RealTimeFeatureService featureService,
                                        ModelUpdateService modelUpdateService,
                                        RecommendationCache recommendationCache,
                                        MetricsCollector metricsCollector) {
        this.userProfileService = userProfileService;
        this.featureService = featureService;
        this.modelUpdateService = modelUpdateService;
        this.recommendationCache = recommendationCache;
        this.metricsCollector = metricsCollector;
    }

    public void startProcessing() {
        try {
            StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();

            // 1. 创建Kafka数据源
            FlinkKafkaConsumer<BehaviorEvent> behaviorConsumer = createBehaviorEventConsumer();
            DataStream<BehaviorEvent> behaviorStream = env.addSource(behaviorConsumer);

            // 2. 水印设置
            behaviorStream = behaviorStream.assignTimestampsAndWatermarks(
                WatermarkStrategy.<BehaviorEvent>forBoundedOutOfOrderness(Duration.ofSeconds(5))
                    .withTimestampAssigner((event, timestamp) -> event.getTimestamp())
            );

            // 3. 实时用户画像更新
            behaviorStream
                .keyBy(BehaviorEvent::getUserId)
                .process(new UserProfileUpdateFunction(userProfileService))
                .name("user-profile-update")
                .uid("user-profile-update");

            // 4. 实时特征计算
            behaviorStream
                .keyBy(event -> event.getUserId() + ":" + event.getItemId())
                .process(new RealTimeFeatureCalculationFunction(featureService))
                .name("realtime-feature-calculation")
                .uid("realtime-feature-calculation");

            // 5. 推荐缓存失效
            behaviorStream
                .filter(event -> shouldInvalidateRecommendationCache(event))
                .keyBy(BehaviorEvent::getUserId)
                .process(new RecommendationCacheInvalidationFunction(recommendationCache))
                .name("recommendation-cache-invalidation")
                .uid("recommendation-cache-invalidation");

            // 6. 模型更新触发
            behaviorStream
                .window(TumblingProcessingTimeWindows.of(Duration.ofMinutes(5)))
                .trigger(ProcessingTimeTrigger.create())
                .process(new ModelUpdateTriggerFunction(modelUpdateService))
                .name("model-update-trigger")
                .uid("model-update-trigger");

            // 7. 异常检测和监控
            behaviorStream
                .process(new AnomalyDetectionFunction(metricsCollector))
                .name("anomaly-detection")
                .uid("anomaly-detection");

            // 8. 数据质量监控
            behaviorStream
                .process(new DataQualityMonitorFunction(metricsCollector))
                .name("data-quality-monitor")
                .uid("data-quality-monitor");

            env.execute("Real-Time Behavior Processing Job");

        } catch (Exception e) {
            log.error("实时行为处理作业启动失败", e);
        }
    }

    private FlinkKafkaConsumer<BehaviorEvent> createBehaviorEventConsumer() {
        Properties properties = new Properties();
        properties.setProperty("bootstrap.servers", "kafka:9092");
        properties.setProperty("group.id", "behavior-processor");
        properties.setProperty("auto.offset.reset", "latest");

        return new FlinkKafkaConsumer<>(
            Arrays.asList("user-behavior", "purchase-events", "item-interactions"),
            new BehaviorEventDeserializer(),
            properties
        );
    }

    private boolean shouldInvalidateRecommendationCache(BehaviorEvent event) {
        // 购买行为或长时间浏览后失效推荐缓存
        return event.getEventType() == EventType.PURCHASE ||
               (event.getEventType() == EventType.VIEW && event.getDuration() > 30000);
    }
}

// 用户画像实时更新函数
public class UserProfileUpdateFunction extends KeyedProcessFunction<String, BehaviorEvent, Void> {

    private final UserProfileService userProfileService;
    private ValueState<UserProfileBuffer> profileBufferState;
    private ValueState<Long> lastUpdateTimeState;

    public UserProfileUpdateFunction(UserProfileService userProfileService) {
        this.userProfileService = userProfileService;
    }

    @Override
    public void open(Configuration parameters) throws Exception {
        super.open(parameters);
        profileBufferState = getRuntimeContext().getState(
            new ValueStateDescriptor<>("profile-buffer", UserProfileBuffer.class)
        );
        lastUpdateTimeState = getRuntimeContext().getState(
            new ValueStateDescriptor<>("last-update-time", Long.class)
        );
    }

    @Override
    public void processElement(BehaviorEvent event, Context ctx, Void out) throws Exception {
        UserProfileBuffer buffer = profileBufferState.value();
        if (buffer == null) {
            buffer = new UserProfileBuffer();
            profileBufferState.update(buffer);
        }

        // 添加事件到缓冲区
        buffer.addEvent(event);

        // 检查是否需要更新用户画像
        if (shouldUpdateProfile(buffer, ctx)) {
            updateUserProfile(event.getUserId(), buffer);
            clearBuffer(buffer);
            updateLastUpdateTime(ctx);
        }
    }

    private boolean shouldUpdateProfile(UserProfileBuffer buffer, Context ctx) throws Exception {
        // 条件1: 缓冲区大小超过阈值
        if (buffer.size() >= 100) {
            return true;
        }

        // 条件2: 距离上次更新超过时间阈值
        Long lastUpdateTime = lastUpdateTimeState.value();
        if (lastUpdateTime != null) {
            long timeSinceLastUpdate = ctx.timerService().currentProcessingTime() - lastUpdateTime;
            if (timeSinceLastUpdate > Duration.ofMinutes(5).toMillis()) {
                return true;
            }
        }

        // 条件3: 包含重要事件（如购买）
        if (buffer.containsImportantEvent()) {
            return true;
        }

        return false;
    }

    private void updateUserProfile(String userId, UserProfileBuffer buffer) {
        try {
            log.info("更新用户画像: userId={}, eventCount={}", userId, buffer.size());

            UserProfile currentProfile = userProfileService.getUserProfile(userId);

            // 计算新的用户画像特征
            UserProfile updatedProfile = calculateUpdatedProfile(currentProfile, buffer);

            // 保存到数据库和缓存
            userProfileService.updateUserProfile(userId, updatedProfile);

            log.info("用户画像更新完成: userId={}", userId);

        } catch (Exception e) {
            log.error("用户画像更新失败: userId={}", userId, e);
        }
    }

    private UserProfile calculateUpdatedProfile(UserProfile currentProfile, UserProfileBuffer buffer) {
        UserProfile.Builder builder = UserProfile.builder()
            .userId(currentProfile.getUserId())
            .basicInfo(currentProfile.getBasicInfo());

        // 1. 更新兴趣偏好
        Map<String, Float> newInterests = calculateInterestPreferences(buffer);
        builder.interestVector(new ArrayList<>(newInterests.values()));

        // 2. 更新行为特征
        BehaviorFeatures newBehaviorFeatures = calculateBehaviorFeatures(buffer);
        builder.purchaseFrequency(newBehaviorFeatures.getPurchaseFrequency());
        builder.avgOrderValue(newBehaviorFeatures.getAvgOrderValue());
        builder.lastActiveTime(newBehaviorFeatures.getLastActiveTime());

        // 3. 更新社交特征
        SocialFeatures newSocialFeatures = calculateSocialFeatures(buffer);
        builder.friendIds(newSocialFeatures.getFriendIds());
        builder.influenceScore(newSocialFeatures.getInfluenceScore());

        // 4. 更新冷启动状态
        builder.coldStart(!isUserActiveEnough(buffer));

        return builder.build();
    }

    private Map<String, Float> calculateInterestPreferences(UserProfileBuffer buffer) {
        Map<String, Float> interests = new HashMap<>();

        // 基于浏览和点击行为计算兴趣偏好
        Map<String, Integer> categoryCounts = new HashMap<>();
        Map<String, Integer> brandCounts = new HashMap<>();

        for (BehaviorEvent event : buffer.getEvents()) {
            if (event.getEventType() == EventType.VIEW || event.getEventType() == EventType.CLICK) {
                String category = event.getCategory();
                String brand = event.getBrand();

                categoryCounts.merge(category, 1, Integer::sum);
                if (brand != null) {
                    brandCounts.merge(brand, 1, Integer::sum);
                }
            }
        }

        // 归一化兴趣分数
        int totalInteractions = categoryCounts.values().stream().mapToInt(Integer::intValue).sum();
        for (Map.Entry<String, Integer> entry : categoryCounts.entrySet()) {
            float score = (float) entry.getValue() / totalInteractions;
            interests.put(entry.getKey(), score);
        }

        return interests;
    }

    private BehaviorFeatures calculateBehaviorFeatures(UserProfileBuffer buffer) {
        List<BehaviorEvent> events = buffer.getEvents();

        // 计算购买频率
        long purchaseCount = events.stream()
            .filter(e -> e.getEventType() == EventType.PURCHASE)
            .count();

        // 计算平均订单价值
        double totalValue = events.stream()
            .filter(e -> e.getEventType() == EventType.PURCHASE)
            .mapToDouble(e -> e.getValue() != null ? e.getValue() : 0.0)
            .sum();

        double avgOrderValue = purchaseCount > 0 ? totalValue / purchaseCount : 0.0;

        // 获取最后活跃时间
        long lastActiveTime = events.stream()
            .mapToLong(BehaviorEvent::getTimestamp)
            .max()
            .orElse(System.currentTimeMillis());

        return new BehaviorFeatures(
            purchaseCount,
            avgOrderValue,
            lastActiveTime
        );
    }

    private SocialFeatures calculateSocialFeatures(UserProfileBuffer buffer) {
        // 简化实现
        return new SocialFeatures(Collections.emptyList(), 0.0f);
    }

    private boolean isUserActiveEnough(UserProfileBuffer buffer) {
        // 判断用户是否足够活跃以脱离冷启动
        int interactionCount = buffer.getEvents().size();
        return interactionCount >= 10;
    }

    private void clearBuffer(UserProfileBuffer buffer) {
        buffer.clear();
    }

    private void updateLastUpdateTime(Context ctx) throws Exception {
        lastUpdateTimeState.update(ctx.timerService().currentProcessingTime());
    }
}

// 实时特征计算函数
public class RealTimeFeatureCalculationFunction extends KeyedProcessFunction<String, BehaviorEvent, FeatureUpdate> {

    private final RealTimeFeatureService featureService;
    private ValueState<FeatureBuffer> featureBufferState;

    public RealTimeFeatureCalculationFunction(RealTimeFeatureService featureService) {
        this.featureService = featureService;
    }

    @Override
    public void open(Configuration parameters) throws Exception {
        super.open(parameters);
        featureBufferState = getRuntimeContext().getState(
            new ValueStateDescriptor<>("feature-buffer", FeatureBuffer.class)
        );
    }

    @Override
    public void processElement(BehaviorEvent event, Context ctx, Collector<FeatureUpdate> out) throws Exception {
        String key = ctx.getCurrentKey();
        String[] parts = key.split(":");
        String userId = parts[0];
        String itemId = parts[1];

        FeatureBuffer buffer = featureBufferState.value();
        if (buffer == null) {
            buffer = new FeatureBuffer();
            featureBufferState.update(buffer);
        }

        buffer.addEvent(event);

        // 实时计算用户-商品交互特征
        UserItemFeatures features = calculateUserItemFeatures(userId, itemId, buffer);

        // 输出特征更新
        FeatureUpdate update = FeatureUpdate.builder()
            .userId(userId)
            .itemId(itemId)
            .features(features.getFeatureVector())
            .timestamp(System.currentTimeMillis())
            .build();

        out.collect(update);

        // 异步更新特征存储
        CompletableFuture.runAsync(() -> {
            try {
                featureService.updateUserItemFeatures(userId, itemId, features);
            } catch (Exception e) {
                log.error("实时特征更新失败: userId={}, itemId={}", userId, itemId, e);
            }
        });

        // 定期清理缓冲区
        if (buffer.size() > 1000) {
            buffer.clear();
        }
    }

    private UserItemFeatures calculateUserItemFeatures(String userId, String itemId, FeatureBuffer buffer) {
        List<BehaviorEvent> events = buffer.getEvents();

        // 计算交互特征
        int viewCount = 0;
        int clickCount = 0;
        int favoriteCount = 0;
        long totalDuration = 0;
        long lastInteractionTime = 0;

        for (BehaviorEvent event : events) {
            switch (event.getEventType()) {
                case VIEW:
                    viewCount++;
                    if (event.getDuration() != null) {
                        totalDuration += event.getDuration();
                    }
                    break;
                case CLICK:
                    clickCount++;
                    break;
                case FAVORITE:
                    favoriteCount++;
                    break;
            }
            lastInteractionTime = Math.max(lastInteractionTime, event.getTimestamp());
        }

        // 计算复合特征
        double clickThroughRate = viewCount > 0 ? (double) clickCount / viewCount : 0.0;
        double averageViewDuration = viewCount > 0 ? (double) totalDuration / viewCount : 0.0;
        double recencyScore = calculateRecencyScore(lastInteractionTime);

        // 构建特征向量
        float[] featureVector = new float[32];
        featureVector[0] = (float) viewCount / 100.0f;        // 归一化浏览次数
        featureVector[1] = (float) clickCount / 100.0f;       // 归一化点击次数
        featureVector[2] = (float) clickThroughRate;         // 点击率
        featureVector[3] = (float) (averageViewDuration / 60000.0); // 平均浏览时长(分钟)
        featureVector[4] = (float) recencyScore;             // 新近性分数
        featureVector[5] = (float) favoriteCount / 10.0f;    // 收藏次数

        return new UserItemFeatures(featureVector);
    }

    private double calculateRecencyScore(long lastInteractionTime) {
        long now = System.currentTimeMillis();
        long hoursSinceLastInteraction = (now - lastInteractionTime) / (1000 * 60 * 60);

        // 越近的交互得分越高
        return Math.exp(-hoursSinceLastInteraction / 24.0);
    }
}

// 推荐缓存失效函数
public class RecommendationCacheInvalidationFunction extends KeyedProcessFunction<String, BehaviorEvent, Void> {

    private final RecommendationCache recommendationCache;

    public RecommendationCacheInvalidationFunction(RecommendationCache recommendationCache) {
        this.recommendationCache = recommendationCache;
    }

    @Override
    public void processElement(BehaviorEvent event, Context ctx, Void out) throws Exception {
        String userId = event.getUserId();

        log.info("失效推荐缓存: userId={}, eventType={}", userId, event.getEventType());

        try {
            // 失效用户的所有推荐缓存
            recommendationCache.invalidateUserRecommendations(userId);

            // 根据事件类型失效特定类型的推荐
            switch (event.getEventType()) {
                case PURCHASE:
                    // 购买后失效购物车推荐
                    recommendationCache.invalidateCartRecommendations(userId);
                    break;
                case SEARCH:
                    // 搜索后失效搜索推荐
                    recommendationCache.invalidateSearchRecommendations(userId);
                    break;
            }

        } catch (Exception e) {
            log.error("推荐缓存失效失败: userId={}", userId, e);
        }
    }
}

// 模型更新触发函数
public class ModelUpdateTriggerFunction extends ProcessWindowFunction<BehaviorEvent, ModelUpdateTrigger, String, TimeWindow> {

    private final ModelUpdateService modelUpdateService;

    public ModelUpdateTriggerFunction(ModelUpdateService modelUpdateService) {
        this.modelUpdateService = modelUpdateService;
    }

    @Override
    public void process(String key,
                       Context ctx,
                       Iterable<BehaviorEvent> events,
                       Collector<ModelUpdateTrigger> out) throws Exception {

        List<BehaviorEvent> eventList = new ArrayList<>();
        for (BehaviorEvent event : events) {
            eventList.add(event);
        }

        if (eventList.size() >= 1000) { // 至少1000个事件才触发模型更新
            log.info("触发模型更新: key={}, eventCount={}", key, eventList.size());

            ModelUpdateTrigger trigger = ModelUpdateTrigger.builder()
                .triggerTime(System.currentTimeMillis())
                .eventType(determineEventType(eventList))
                .eventCount(eventList.size())
                .windowStart(ctx.window().getStart())
                .windowEnd(ctx.window().getEnd())
                .build();

            out.collect(trigger);

            // 异步执行模型更新
            CompletableFuture.runAsync(() -> {
                try {
                    modelUpdateService.triggerModelUpdate(trigger);
                } catch (Exception e) {
                    log.error("模型更新失败: trigger={}", trigger, e);
                }
            });
        }
    }

    private String determineEventType(List<BehaviorEvent> events) {
        Map<EventType, Long> typeCounts = events.stream()
            .collect(Collectors.groupingBy(
                BehaviorEvent::getEventType,
                Collectors.counting()
            ));

        return typeCounts.entrySet().stream()
            .max(Map.Entry.comparingByValue())
            .map(entry -> entry.getKey().name())
            .orElse("MIXED");
    }
}

// 数据结构定义
@Data
@AllArgsConstructor
@NoArgsConstructor
public class BehaviorEvent {
    private String eventId;
    private String userId;
    private String itemId;
    private EventType eventType;
    private String sessionId;
    private Long timestamp;
    private String category;
    private String brand;
    private Double value;
    private Long duration;
    private String deviceId;
    private String location;
    private Map<String, Object> metadata;
}

public enum EventType {
    VIEW, CLICK, FAVORITE, ADD_TO_CART, PURCHASE, SEARCH, SHARE
}

@Data
@Builder
public class FeatureUpdate {
    private String userId;
    private String itemId;
    private float[] features;
    private long timestamp;
}

@Data
@Builder
public class ModelUpdateTrigger {
    private long triggerTime;
    private String eventType;
    private int eventCount;
    private long windowStart;
    private long windowEnd;
}
```

---

**总结**: 亿级用户电商推荐系统是一个复杂的系统工程，需要综合考虑架构设计、算法选择、数据处理、性能优化等多个方面。通过构建分层的系统架构、实现多模型融合的推荐算法、设计实时数据流处理管道，可以构建出能够支撑亿级用户的推荐系统。关键在于平衡系统的准确性、实时性和可扩展性，并建立完善的监控和优化机制。