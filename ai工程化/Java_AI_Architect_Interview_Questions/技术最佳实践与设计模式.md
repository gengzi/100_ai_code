# æŠ€æœ¯æœ€ä½³å®è·µä¸è®¾è®¡æ¨¡å¼

## ğŸ“‹ æ¦‚è¿°

æœ¬æ–‡æ¡£æ€»ç»“äº†Java AIå¼€å‘ä¸­çš„æœ€ä½³å®è·µå’Œå¸¸ç”¨è®¾è®¡æ¨¡å¼ï¼Œå¸®åŠ©å¼€å‘è€…æ„å»ºé«˜è´¨é‡ã€å¯ç»´æŠ¤çš„AIåº”ç”¨ç³»ç»Ÿã€‚

## ğŸ—ï¸ æ¶æ„è®¾è®¡æ¨¡å¼

### 1. å¾®æœåŠ¡æ¶æ„æ¨¡å¼

#### Service Meshæ¨¡å¼
```java
// æœåŠ¡ç½‘æ ¼ä»£ç†é…ç½®
@Configuration
public class ServiceMeshConfiguration {

    @Bean
    public IstioProperties istioProperties() {
        return IstioProperties.builder()
            .enableTracing(true)
            .enableCircuitBreaker(true)
            .enableRetries(true)
            .enableLoadBalancing(true)
            .build();
    }

    @Bean
    @LoadBalanced
    public RestTemplate loadBalancedRestTemplate() {
        return new RestTemplateBuilder()
            .setConnectTimeout(Duration.ofSeconds(5))
            .setReadTimeout(Duration.ofSeconds(30))
            .build();
    }
}
```

#### API Gatewayæ¨¡å¼
```java
@RestController
@RequestMapping("/api/v1")
public class APIGateway {

    private final RouteLocator routeLocator;
    private final SecurityFilter securityFilter;
    private final RateLimiter rateLimiter;

    @PostMapping("/ai/inference")
    public ResponseEntity<?> handleInferenceRequest(
            @RequestBody InferenceRequest request) {

        // å®‰å…¨æ£€æŸ¥
        if (!securityFilter.validateRequest(request)) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();
        }

        // é™æµæ£€æŸ¥
        if (!rateLimiter.allowRequest(request.getApiKey())) {
            return ResponseEntity.status(HttpStatus.TOO_MANY_REQUESTS).build();
        }

        // è·¯ç”±åˆ°åç«¯æœåŠ¡
        Route route = routeLocator.getRoute("/ai/inference");
        return route.getService().handleRequest(request);
    }
}
```

### 2. äº‹ä»¶é©±åŠ¨æ¶æ„æ¨¡å¼

#### Command Query Responsibility Segregation (CQRS)
```java
// å‘½ä»¤å¤„ç†
@Service
public class AIModelCommandHandler {

    private final ModelRepository modelRepository;
    private final EventPublisher eventPublisher;

    @Transactional
    public void handle(CreateModelCommand command) {
        AIModel model = new AIModel(command);
        modelRepository.save(model);

        eventPublisher.publish(new ModelCreatedEvent(model.getId()));
    }

    @Transactional
    public void handle(UpdateModelCommand command) {
        AIModel model = modelRepository.findById(command.getModelId());
        model.update(command);
        modelRepository.save(model);

        eventPublisher.publish(new ModelUpdatedEvent(model.getId()));
    }
}

// æŸ¥è¯¢å¤„ç†
@Service
public class AIModelQueryHandler {

    private final ModelReadModel readModel;

    public ModelDTO getModel(UUID modelId) {
        return readModel.findModelById(modelId);
    }

    public List<ModelDTO> getModelsByStatus(ModelStatus status) {
        return readModel.findByStatus(status);
    }
}
```

#### Event Sourcingæ¨¡å¼
```java
// äº‹ä»¶å­˜å‚¨
@Component
public class EventStore {

    private final EventRepository eventRepository;

    public void saveEvent(UUID aggregateId, DomainEvent event) {
        EventRecord record = EventRecord.builder()
            .aggregateId(aggregateId)
            .eventType(event.getClass().getSimpleName())
            .eventData(event.serialize())
            .timestamp(Instant.now())
            .build();

        eventRepository.save(record);
    }

    public List<DomainEvent> getEvents(UUID aggregateId, long fromVersion) {
        return eventRepository.findByAggregateIdAndVersionGreaterThan(
            aggregateId, fromVersion)
            .stream()
            .map(this::deserializeEvent)
            .collect(Collectors.toList());
    }
}

// èšåˆæ ¹
public class ModelAggregate {

    private UUID id;
    private long version;
    private List<DomainEvent> pendingEvents = new ArrayList<>();

    public void create(CreateModelCommand command) {
        apply(new ModelCreatedEvent(command));
    }

    public void update(UpdateModelCommand command) {
        validateUpdate(command);
        apply(new ModelUpdatedEvent(command));
    }

    private void apply(DomainEvent event) {
        whenApply(event);
        pendingEvents.add(event);
        version++;
    }

    public List<DomainEvent> getUncommittedEvents() {
        return Collections.unmodifiableList(pendingEvents);
    }

    public void markEventsAsCommitted() {
        pendingEvents.clear();
    }
}
```

## ğŸ”§ ä»£ç è®¾è®¡æ¨¡å¼

### 1. å»ºé€ è€…æ¨¡å¼ (Builder Pattern)

#### AIæ¨¡å‹é…ç½®å»ºé€ è€…
```java
public class AIModelConfig {
    private final String modelType;
    private final Map<String, Object> parameters;
    private final ResourceConstraints constraints;
    private final OptimizationStrategy strategy;

    private AIModelConfig(Builder builder) {
        this.modelType = builder.modelType;
        this.parameters = builder.parameters;
        this.constraints = builder.constraints;
        this.strategy = builder.strategy;
    }

    public static class Builder {
        private String modelType;
        private Map<String, Object> parameters = new HashMap<>();
        private ResourceConstraints constraints;
        private OptimizationStrategy strategy = OptimizationStrategy.DEFAULT;

        public Builder modelType(String modelType) {
            this.modelType = modelType;
            return this;
        }

        public Builder parameter(String key, Object value) {
            this.parameters.put(key, value);
            return this;
        }

        public Builder constraints(ResourceConstraints constraints) {
            this.constraints = constraints;
            return this;
        }

        public Builder strategy(OptimizationStrategy strategy) {
            this.strategy = strategy;
            return this;
        }

        public AIModelConfig build() {
            return new AIModelConfig(this);
        }
    }

    // ä½¿ç”¨ç¤ºä¾‹
    public static void main(String[] args) {
        AIModelConfig config = new Builder()
            .modelType("NEURAL_NETWORK")
            .parameter("hiddenLayers", 3)
            .parameter("activation", "ReLU")
            .parameter("learningRate", 0.001)
            .constraints(ResourceConstraints.memory(8192))
            .strategy(OptimizationStrategy.ADAM)
            .build();
    }
}
```

### 2. å·¥å‚æ¨¡å¼ (Factory Pattern)

#### AIæ¨ç†æœåŠ¡å·¥å‚
```java
public interface InferenceServiceFactory {
    InferenceService createInferenceService(String modelType, ModelConfig config);
}

@Component
public class DefaultInferenceServiceFactory implements InferenceServiceFactory {

    private final Map<String, InferenceServiceBuilder> builders;

    public DefaultInferenceServiceFactory(
            List<InferenceServiceBuilder> builderList) {
        this.builders = builderList.stream()
            .collect(Collectors.toMap(
                InferenceServiceBuilder::getSupportedModelType,
                Function.identity()
            ));
    }

    @Override
    public InferenceService createInferenceService(String modelType, ModelConfig config) {
        InferenceServiceBuilder builder = builders.get(modelType);
        if (builder == null) {
            throw new UnsupportedModelTypeException("Unsupported model type: " + modelType);
        }
        return builder.build(config);
    }
}

@Component
public class NeuralNetworkInferenceServiceBuilder implements InferenceServiceBuilder {

    @Override
    public String getSupportedModelType() {
        return "NEURAL_NETWORK";
    }

    @Override
    public InferenceService build(ModelConfig config) {
        NeuralNetworkModel model = loadNeuralNetworkModel(config);
        return new NeuralNetworkInferenceService(model, config);
    }

    private NeuralNetworkModel loadNeuralNetworkModel(ModelConfig config) {
        // åŠ è½½å’Œé…ç½®ç¥ç»ç½‘ç»œæ¨¡å‹
        return NeuralNetworkModel.builder()
            .architecture(config.getParameters())
            .constraints(config.getConstraints())
            .build();
    }
}
```

### 3. ç­–ç•¥æ¨¡å¼ (Strategy Pattern)

#### æ¨ç†ç­–ç•¥é€‰æ‹©
```java
public interface InferenceStrategy {
    CompletableFuture<InferenceResult> infer(InferenceRequest request);
    boolean isApplicable(InferenceRequest request);
}

@Component
public class FastInferenceStrategy implements InferenceStrategy {

    private final FastModelCache cache;
    private final LightweightModel model;

    @Override
    public CompletableFuture<InferenceResult> infer(InferenceRequest request) {
        return CompletableFuture.supplyAsync(() -> {
            // ä½¿ç”¨ç¼“å­˜å’Œè½»é‡çº§æ¨¡å‹å¿«é€Ÿæ¨ç†
            return cache.get(request)
                .orElseGet(() -> model.predict(request));
        });
    }

    @Override
    public boolean isApplicable(InferenceRequest request) {
        return request.isLowLatency() && !request.isHighAccuracy();
    }
}

@Component
public class AccurateInferenceStrategy implements InferenceStrategy {

    private final HeavyweightModel model;

    @Override
    public CompletableFuture<InferenceResult> infer(InferenceRequest request) {
        return CompletableFuture.supplyAsync(() -> {
            // ä½¿ç”¨é«˜ç²¾åº¦æ¨¡å‹è¿›è¡Œæ¨ç†
            return model.predictWithHighAccuracy(request);
        });
    }

    @Override
    public boolean isApplicable(InferenceRequest request) {
        return request.isHighAccuracy() && !request.isLowLatency();
    }
}

@Service
public class InferenceStrategySelector {

    private final List<InferenceStrategy> strategies;

    public InferenceStrategySelector(List<InferenceStrategy> strategies) {
        this.strategies = strategies;
    }

    public InferenceStrategy selectStrategy(InferenceRequest request) {
        return strategies.stream()
            .filter(strategy -> strategy.isApplicable(request))
            .findFirst()
            .orElseThrow(() -> new NoApplicableStrategyException("No suitable strategy found"));
    }
}
```

### 4. è§‚å¯Ÿè€…æ¨¡å¼ (Observer Pattern)

#### æ¨¡å‹è®­ç»ƒç›‘æ§
```java
public interface TrainingObserver {
    void onEpochCompleted(TrainingEpoch epoch);
    void onTrainingCompleted(TrainingResult result);
    void onError(TrainingError error);
}

@Component
public class TrainingMonitor implements TrainingObserver {

    private final MetricsCollector metricsCollector;
    private final AlertService alertService;

    @Override
    public void onEpochCompleted(TrainingEpoch epoch) {
        // æ”¶é›†è®­ç»ƒæŒ‡æ ‡
        TrainingMetrics metrics = metricsCollector.collect(epoch);

        // è®°å½•è®­ç»ƒè¿›åº¦
        logTrainingProgress(epoch, metrics);

        // æ£€æŸ¥æ˜¯å¦éœ€è¦æ—©åœ
        if (shouldEarlyStop(metrics)) {
            throw new EarlyStopException("Early stopping triggered");
        }
    }

    @Override
    public void onTrainingCompleted(TrainingResult result) {
        // ä¿å­˜è®­ç»ƒç»“æœ
        saveTrainingResult(result);

        // æ¨¡å‹è¯„ä¼°
        evaluateModel(result.getModel());

        // å‘é€å®Œæˆé€šçŸ¥
        sendCompletionNotification(result);
    }

    @Override
    public void onError(TrainingError error) {
        log.error("Training error occurred", error);
        alertService.sendErrorAlert(error);

        // å°è¯•æ¢å¤æˆ–æ¸…ç†èµ„æº
        handleTrainingError(error);
    }
}

@Service
public class ModelTrainer {

    private final List<TrainingObserver> observers;
    private final TrainingConfiguration config;

    public void trainModel(Model model, Dataset dataset) {
        try {
            for (int epoch = 0; epoch < config.getMaxEpochs(); epoch++) {
                TrainingEpoch trainingEpoch = trainEpoch(model, dataset, epoch);

                // é€šçŸ¥è§‚å¯Ÿè€…
                notifyEpochCompleted(trainingEpoch);
            }

            TrainingResult result = completeTraining(model);
            notifyTrainingCompleted(result);

        } catch (Exception e) {
            notifyErrorOccurred(new TrainingError(e));
        }
    }

    private void notifyEpochCompleted(TrainingEpoch epoch) {
        observers.forEach(observer -> observer.onEpochCompleted(epoch));
    }

    private void notifyTrainingCompleted(TrainingResult result) {
        observers.forEach(observer -> observer.onTrainingCompleted(result));
    }

    private void notifyErrorOccurred(TrainingError error) {
        observers.forEach(observer -> observer.onError(error));
    }
}
```

## ğŸ”’ å®‰å…¨æœ€ä½³å®è·µ

### 1. APIå®‰å…¨

#### JWTè®¤è¯å’Œæˆæƒ
```java
@Configuration
@EnableWebSecurity
public class APISecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf().disable()
            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            .authorizeHttpRequests(authz -> authz
                .requestMatchers("/api/v1/auth/**").permitAll()
                .requestMatchers("/api/v1/public/**").permitAll()
                .anyRequest().authenticated()
            )
            .addFilterBefore(jwtAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class)
            .addFilterBefore(rateLimitFilter(), JwtAuthenticationFilter.class);

        return http.build();
    }

    @Bean
    public JwtAuthenticationFilter jwtAuthenticationFilter() {
        return new JwtAuthenticationFilter();
    }

    @Bean
    public RateLimitFilter rateLimitFilter() {
        return new RateLimitFilter(rateLimitProperties());
    }
}
```

#### è¾“å…¥éªŒè¯å’Œæ¸…ç†
```java
@Component
public class InputValidator {

    private final XSSFilter xssFilter;
    private final SQLInjectionFilter sqlFilter;

    public ValidationResult validateInferenceRequest(InferenceRequest request) {
        ValidationResult result = new ValidationResult();

        // éªŒè¯è¾“å…¥æ•°æ®
        if (request.getData() == null || request.getData().isEmpty()) {
            result.addError("Input data cannot be empty");
        }

        // XSSé˜²æŠ¤
        String cleanedData = xssFilter.clean(request.getData());
        if (!cleanedData.equals(request.getData())) {
            result.addError("Invalid characters detected in input");
            request.setData(cleanedData);
        }

        // å¤§å°é™åˆ¶
        if (request.getData().length() > MAX_INPUT_LENGTH) {
            result.addError("Input data exceeds maximum length");
        }

        // æ ¼å¼éªŒè¯
        if (!isValidInputFormat(request.getData())) {
            result.addError("Invalid input format");
        }

        return result;
    }

    private boolean isValidInputFormat(String data) {
        try {
            // éªŒè¯JSONæ ¼å¼ï¼ˆå¦‚æœé€‚ç”¨ï¼‰
            if (isJsonInput(data)) {
                JsonUtils.parseObject(data);
            }
            return true;
        } catch (Exception e) {
            return false;
        }
    }
}
```

### 2. æ•°æ®åŠ å¯†

#### æ•æ„Ÿæ•°æ®åŠ å¯†
```java
@Component
public class DataEncryptionService {

    private final AESUtil aesUtil;
    private final RSAUtil rsaUtil;

    @Value("${encryption.key}")
    private String encryptionKey;

    public String encryptSensitiveData(String data) {
        try {
            // ä½¿ç”¨AESåŠ å¯†æ•°æ®
            return aesUtil.encrypt(data, encryptionKey);
        } catch (Exception e) {
            throw new EncryptionException("Failed to encrypt data", e);
        }
    }

    public String decryptSensitiveData(String encryptedData) {
        try {
            // ä½¿ç”¨AESè§£å¯†æ•°æ®
            return aesUtil.decrypt(encryptedData, encryptionKey);
        } catch (Exception e) {
            throw new DecryptionException("Failed to decrypt data", e);
        }
    }

    public String encryptWithPublicKey(String data, String publicKey) {
        try {
            return rsaUtil.encrypt(data, publicKey);
        } catch (Exception e) {
            throw new EncryptionException("Failed to encrypt with public key", e);
        }
    }
}

// æ¨¡å‹æ–‡ä»¶åŠ å¯†å­˜å‚¨
@Service
public class SecureModelStorage {

    private final DataEncryptionService encryptionService;
    private final ModelRepository modelRepository;

    public void storeEncryptedModel(UUID modelId, ModelFile modelFile) {
        try {
            // åŠ å¯†æ¨¡å‹æ–‡ä»¶
            String encryptedContent = encryptionService.encryptModelFile(modelFile);

            // å­˜å‚¨åŠ å¯†åçš„æ¨¡å‹
            EncryptedModel encryptedModel = new EncryptedModel(
                modelId,
                encryptedContent,
                modelFile.getMetadata()
            );

            modelRepository.save(encryptedModel);

        } catch (Exception e) {
            throw new ModelStorageException("Failed to store encrypted model", e);
        }
    }

    public ModelFile decryptModel(UUID modelId) {
        EncryptedModel encryptedModel = modelRepository.findById(modelId);
        if (encryptedModel == null) {
            throw new ModelNotFoundException("Model not found: " + modelId);
        }

        try {
            String decryptedContent = encryptionService.decryptModelFile(
                encryptedModel.getEncryptedContent());

            return ModelFile.fromEncryptedContent(decryptedContent, encryptedModel.getMetadata());

        } catch (Exception e) {
            throw new ModelDecryptionException("Failed to decrypt model", e);
        }
    }
}
```

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–æœ€ä½³å®è·µ

### 1. å†…å­˜ç®¡ç†

#### å¯¹è±¡æ± åŒ–
```java
@Component
public class InferenceRequestPool {

    private final ObjectPool<InferenceRequest> requestPool;
    private final ObjectPool<InferenceResult> resultPool;

    public InferenceRequestPool() {
        this.requestPool = new GenericObjectPool<>(
            new InferenceRequestFactory(),
            new BasePooledObjectConfig<>());

        this.resultPool = new GenericObjectPool<>(
            new InferenceResultFactory(),
            new BasePooledObjectConfig<>());
    }

    public InferenceRequest borrowRequest() throws Exception {
        return requestPool.borrowObject();
    }

    public void returnRequest(InferenceRequest request) {
        try {
            request.reset();
            requestPool.returnObject(request);
        } catch (Exception e) {
            log.warn("Failed to return request to pool", e);
        }
    }

    public CompletableFuture<InferenceResult> borrowResult() {
        try {
            InferenceResult result = resultPool.borrowObject();
            return CompletableFuture.completedFuture(result);
        } catch (Exception e) {
            return CompletableFuture.failedFuture(e);
        }
    }
}
```

#### å†…å­˜ä¼˜åŒ–
```java
@Component
public class MemoryOptimizedProcessor {

    private final MemoryMonitor memoryMonitor;
    private final Cache<String, WeakReference<ComputationResult>> resultCache;

    public void processLargeDataset(Dataset dataset) {
        // åˆ†æ‰¹å¤„ç†å¤§æ•°æ®é›†
        int batchSize = calculateOptimalBatchSize();

        dataset.getBatchedStream(batchSize)
            .forEach(this::processBatch);
    }

    private int calculateOptimalBatchSize() {
        long availableMemory = memoryMonitor.getAvailableMemory();
        long estimatedMemoryPerItem = estimateMemoryPerItem();

        // ä¿ç•™80%çš„å¯ç”¨å†…å­˜ç»™ç³»ç»Ÿ
        long safeMemory = (long) (availableMemory * 0.8);

        return (int) Math.max(1, safeMemory / estimatedMemoryPerItem);
    }

    public ComputationResult getCachedResult(String cacheKey) {
        WeakReference<ComputationResult> ref = resultCache.get(cacheKey);
        if (ref != null) {
            ComputationResult result = ref.get();
            if (result != null) {
                return result;
            } else {
                resultCache.remove(cacheKey);
            }
        }
        return null;
    }

    public void cacheResult(String cacheKey, ComputationResult result) {
        resultCache.put(cacheKey, new WeakReference<>(result));
    }
}
```

### 2. å¹¶å‘å¤„ç†

#### çº¿ç¨‹æ± é…ç½®
```java
@Configuration
public class ThreadPoolConfiguration {

    @Bean
    @Primary
    public TaskExecutor inferenceTaskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();

        // æ ¸å¿ƒçº¿ç¨‹æ•° = CPUæ ¸å¿ƒæ•°
        int corePoolSize = Runtime.getRuntime().availableProcessors();
        executor.setCorePoolSize(corePoolSize);

        // æœ€å¤§çº¿ç¨‹æ•° = CPUæ ¸å¿ƒæ•° * 2
        executor.setMaxPoolSize(corePoolSize * 2);

        // é˜Ÿåˆ—å®¹é‡
        executor.setQueueCapacity(1000);

        // çº¿ç¨‹åå‰ç¼€
        executor.setThreadNamePrefix("inference-");

        // æ‹’ç»ç­–ç•¥
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());

        // ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆåå†å…³é—­
        executor.setWaitForTasksToCompleteOnShutdown(true);
        executor.setAwaitTerminationSeconds(60);

        executor.initialize();
        return executor;
    }

    @Bean
    public TaskExecutor batchProcessingExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();

        // æ‰¹å¤„ç†é€šå¸¸éœ€è¦è¾ƒå°‘çš„çº¿ç¨‹
        executor.setCorePoolSize(2);
        executor.setMaxPoolSize(4);
        executor.setQueueCapacity(100);
        executor.setThreadNamePrefix("batch-");
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());

        executor.initialize();
        return executor;
    }

    @Bean
    public TaskExecutor ioTaskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();

        // IOå¯†é›†å‹ä»»åŠ¡å¯ä»¥ä½¿ç”¨æ›´å¤šçº¿ç¨‹
        int ioThreads = Runtime.getRuntime().availableProcessors() * 4;
        executor.setCorePoolSize(ioThreads);
        executor.setMaxPoolSize(ioThreads * 2);
        executor.setQueueCapacity(1000);
        executor.setThreadNamePrefix("io-");
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.AbortPolicy());

        executor.initialize();
        return executor;
    }
}
```

#### å¼‚æ­¥å¤„ç†
```java
@Service
public class AsyncInferenceService {

    private final TaskExecutor inferenceTaskExecutor;
    private final CompletionService<InferenceResult> completionService;

    public AsyncInferenceService(TaskExecutor inferenceTaskExecutor) {
        this.inferenceTaskExecutor = inferenceTaskExecutor;
        this.completionService = new ExecutorCompletionService<>(inferenceTaskExecutor);
    }

    public CompletableFuture<List<InferenceResult>> processBatch(List<InferenceRequest> requests) {
        List<CompletableFuture<InferenceResult>> futures = new ArrayList<>();

        // æäº¤æ‰€æœ‰ä»»åŠ¡
        for (InferenceRequest request : requests) {
            CompletableFuture<InferenceResult> future = CompletableFuture.supplyAsync(
                () -> processSingleRequest(request), inferenceTaskExecutor);
            futures.add(future);
        }

        // ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
        return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
            .thenApply(v -> futures.stream()
                .map(CompletableFuture::join)
                .collect(Collectors.toList()));
    }

    public InferenceResult processWithTimeout(InferenceRequest request, Duration timeout) {
        try {
            Future<InferenceResult> future = completionService.submit(
                () -> processSingleRequest(request));

            return future.get(timeout.toMillis(), TimeUnit.MILLISECONDS);
        } catch (TimeoutException e) {
            throw new InferenceTimeoutException("Inference timeout", e);
        } catch (Exception e) {
            throw new InferenceException("Inference failed", e);
        }
    }

    public void processWithCallback(InferenceRequest request, Consumer<InferenceResult> callback) {
        CompletableFuture.supplyAsync(() -> processSingleRequest(request), inferenceTaskExecutor)
            .thenAccept(callback)
            .exceptionally(throwable -> {
                log.error("Inference failed for request: " + request.getId(), throwable);
                return null;
            });
    }
}
```

## ğŸ§ª æµ‹è¯•æœ€ä½³å®è·µ

### 1. å•å…ƒæµ‹è¯•

#### AIæ¨¡å‹æµ‹è¯•
```java
@ExtendWith(MockitoExtension.class)
class NeuralNetworkServiceTest {

    @Mock
    private ModelRepository modelRepository;

    @Mock
    private InferenceEngine inferenceEngine;

    @InjectMocks
    private NeuralNetworkService neuralNetworkService;

    @Test
    @DisplayName("åº”è¯¥æˆåŠŸè¿›è¡Œæ¨¡å‹æ¨ç†")
    void shouldPerformInferenceSuccessfully() {
        // Given
        String modelId = "model-123";
        InferenceRequest request = createTestRequest(modelId);
        Model model = createTestModel(modelId);
        InferenceResult expectedResult = createExpectedResult();

        when(modelRepository.findById(modelId)).thenReturn(Optional.of(model));
        when(inferenceEngine.infer(model, request)).thenReturn(expectedResult);

        // When
        CompletableFuture<InferenceResult> result = neuralNetworkService.infer(request);

        // Then
        assertThat(result).succeedsWith(expectedResult);
        verify(modelRepository).findById(modelId);
        verify(inferenceEngine).infer(model, request);
    }

    @Test
    @DisplayName("åº”è¯¥å¤„ç†æ¨¡å‹ä¸å­˜åœ¨çš„æƒ…å†µ")
    void shouldHandleModelNotFound() {
        // Given
        String modelId = "non-existent-model";
        InferenceRequest request = createTestRequest(modelId);

        when(modelRepository.findById(modelId)).thenReturn(Optional.empty());

        // When & Then
        assertThatThrownBy(() -> neuralNetworkService.infer(request).get())
            .isInstanceOf(ModelNotFoundException.class)
            .hasMessage("Model not found: " + modelId);
    }

    @Test
    @DisplayName("åº”è¯¥å¤„ç†æ¨ç†å¤±è´¥çš„æƒ…å†µ")
    void shouldHandleInferenceFailure() {
        // Given
        String modelId = "model-123";
        InferenceRequest request = createTestRequest(modelId);
        Model model = createTestModel(modelId);

        when(modelRepository.findById(modelId)).thenReturn(Optional.of(model));
        when(inferenceEngine.infer(model, request))
            .thenThrow(new InferenceException("Model inference failed"));

        // When
        CompletableFuture<InferenceResult> result = neuralNetworkService.infer(request);

        // Then
        assertThat(result).failsWithInstanceOf(InferenceException.class);
    }
}
```

### 2. é›†æˆæµ‹è¯•

#### APIé›†æˆæµ‹è¯•
```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@TestPropertySource(locations = "classpath:test.properties")
class AIControllerIntegrationTest {

    @Autowired
    private TestRestTemplate restTemplate;

    @Autowired
    private ModelRepository modelRepository;

    @Autowired
    private TestDataFactory testDataFactory;

    @Test
    @DisplayName("åº”è¯¥æˆåŠŸå¤„ç†æ¨ç†è¯·æ±‚")
    void shouldProcessInferenceSuccessfully() {
        // Given
        Model model = testDataFactory.createModel();
        modelRepository.save(model);

        InferenceRequest request = createTestRequest(model.getId());

        // When
        ResponseEntity<ApiResponse> response = restTemplate.postForEntity(
            "/api/v1/inference", request, ApiResponse.class);

        // Then
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(response.getBody().isSuccess()).isTrue();
        assertThat(response.getBody().getData()).isNotNull();
    }

    @Test
    @DisplayName("åº”è¯¥éªŒè¯è¯·æ±‚å‚æ•°")
    void shouldValidateRequestParameters() {
        // Given
        InferenceRequest invalidRequest = new InferenceRequest();
        // æ•…æ„ä¸è®¾ç½®å¿…è¦å­—æ®µ

        // When
        ResponseEntity<ApiResponse> response = restTemplate.postForEntity(
            "/api/v1/inference", invalidRequest, ApiResponse.class);

        // Then
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.BAD_REQUEST);
        assertThat(response.getBody().isSuccess()).isFalse();
        assertThat(response.getBody().getErrorMessage()).contains("validation failed");
    }
}
```

### 3. æ€§èƒ½æµ‹è¯•

#### è´Ÿè½½æµ‹è¯•
```java
@TestMethodOrder(Ordered.HIGHEST_PRECEDENCE)
public class InferenceServiceLoadTest {

    private static final int THREAD_COUNT = 10;
    private static final int REQUESTS_PER_THREAD = 1000;
    private static final Duration WARMUP_TIME = Duration.ofSeconds(30);
    private static final Duration TEST_TIME = Duration.ofMinutes(2);

    @Autowired
    private InferenceService inferenceService;

    @Test
    @DisplayName("è´Ÿè½½æµ‹è¯•ï¼šé«˜å¹¶å‘æ¨ç†")
    void loadTestHighConcurrencyInference() throws InterruptedException {
        // é¢„çƒ­
        warmupService();

        // å‡†å¤‡æµ‹è¯•æ•°æ®
        List<InferenceRequest> requests = prepareTestRequests(
            THREAD_COUNT * REQUESTS_PER_THREAD);

        ExecutorService executor = Executors.newFixedThreadPool(THREAD_COUNT);
        CountDownLatch latch = new CountDownLatch(THREAD_COUNT);
        List<Future<TestResult>> futures = new ArrayList<>();

        // æ‰§è¡Œè´Ÿè½½æµ‹è¯•
        for (int i = 0; i < THREAD_COUNT; i++) {
            int startIndex = i * REQUESTS_PER_THREAD;
            List<InferenceRequest> threadRequests = requests.subList(
                startIndex, startIndex + REQUESTS_PER_THREAD);

            Future<TestResult> future = executor.submit(
                new LoadTestWorker(inferenceService, threadRequests, latch));
            futures.add(future);
        }

        // ç­‰å¾…æ‰€æœ‰çº¿ç¨‹å®Œæˆ
        assertTrue(latch.await(TEST_TIME.toMillis(), TimeUnit.MILLISECONDS));

        // æ”¶é›†å’Œåˆ†æç»“æœ
        List<TestResult> results = futures.stream()
            .map(future -> {
                try {
                    return future.get();
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
            })
            .collect(Collectors.toList());

        analyzeResults(results);
    }

    private void warmupService() throws InterruptedException {
        // é¢„çƒ­æœåŠ¡ï¼Œé¿å…å†·å¯åŠ¨å½±å“æµ‹è¯•ç»“æœ
        for (int i = 0; i < 100; i++) {
            InferenceRequest warmupRequest = createTestRequest("warmup-" + i);
            inferenceService.infer(warmupRequest);
        }
        Thread.sleep(WARMUP_TIME.toMillis());
    }

    private void analyzeResults(List<TestResult> results) {
        Statistics stats = results.stream()
            .collect(Collectors.summarizingStatistics(
                TestResult::getLatency,
                TestResult::isSuccess,
                TestResult::getError
            ));

        System.out.println("è´Ÿè½½æµ‹è¯•ç»“æœ:");
        System.out.println("æ€»è¯·æ±‚æ•°: " + stats.getCount());
        System.out.println("æˆåŠŸç‡: " + String.format("%.2f%%", stats.getSuccessRate()));
        System.out.println("å¹³å‡å»¶è¿Ÿ: " + String.format("%.2fms", stats.getAverageLatency()));
        System.out.println("P95å»¶è¿Ÿ: " + String.format("%.2fms", stats.getP95Latency()));
        System.out.println("P99å»¶è¿Ÿ: " + String.format("%.2fms", stats.getP99Latency()));
        System.out.println("ååé‡: " + String.format("%.2f req/s", stats.getThroughput()));

        // æ€§èƒ½æ–­è¨€
        assertThat(stats.getSuccessRate()).isGreaterThan(0.99);
        assertThat(stats.getP95Latency()).isLessThan(100.0);
        assertThat(stats.getThroughput()).isGreaterThan(100.0);
    }
}
```

## ğŸ“ˆ ç›‘æ§å’Œæ—¥å¿—

### 1. åº”ç”¨ç›‘æ§

#### æŒ‡æ ‡æ”¶é›†
```java
@Component
public class AIPrometheusMetrics {

    private final Counter inferenceRequestTotal;
    private final Counter inferenceErrorTotal;
    private final Timer inferenceDuration;
    private final Gauge activeModels;
    private final Histogram inferenceLatency;

    public AIPrometheusMetrics(MeterRegistry meterRegistry) {
        this.inferenceRequestTotal = Counter.builder("ai_inference_requests_total")
            .description("Total number of inference requests")
            .tag("model_type", "unknown")
            .register(meterRegistry);

        this.inferenceErrorTotal = Counter.builder("ai_inference_errors_total")
            .description("Total number of inference errors")
            .register(meterRegistry);

        this.inferenceDuration = Timer.builder("ai_inference_duration_seconds")
            .description("Inference request duration")
            .register(meterRegistry);

        this.activeModels = Gauge.builder("ai_active_models")
            .description("Number of active AI models")
            .register(meterRegistry, this, AIPrometheusMetrics::getActiveModelCount);

        this.inferenceLatency = Histogram.builder("ai_inference_latency")
            .description("Inference latency distribution")
            .publishPercentiles(0.5, 0.95, 0.99)
            .register(meterRegistry);
    }

    public void recordInferenceRequest(String modelType) {
        inferenceRequestTotal.increment(Tags.of("model_type", modelType));
    }

    public void recordInferenceError(String errorType) {
        inferenceErrorTotal.increment(Tags.of("error_type", errorType));
    }

    public Timer.Sample startInferenceTimer() {
        return Timer.start(inferenceDuration);
    }

    public void recordInferenceLatency(double latency) {
        inferenceLatency.observe(latency);
    }

    private double getActiveModelCount() {
        // è¿”å›å½“å‰æ´»è·ƒæ¨¡å‹æ•°é‡
        return modelService.getActiveModelCount();
    }
}
```

### 2. ç»“æ„åŒ–æ—¥å¿—

#### æ—¥å¿—é…ç½®
```java
@Configuration
public class LoggingConfiguration {

    @Bean
    public Logger structuredLogger() {
        return LoggerFactory.getLogger("ai.structured.logger");
    }

    public void logInferenceStart(InferenceRequest request) {
        MDC.put("requestId", request.getId().toString());
        MDC.put("modelId", request.getModelId());
        MDC.put("userId", request.getUserId().toString());

        if (structuredLogger.isInfoEnabled()) {
            structuredLogger.info("Inference request started");
        }
    }

    public void logInferenceComplete(InferenceRequest request, InferenceResult result) {
        MDC.put("latency", String.valueOf(result.getLatency()));
        MDC.put("success", String.valueOf(result.isSuccess()));

        if (result.isSuccess()) {
            structuredLogger.info("Inference request completed successfully");
        } else {
            structuredLogger.warn("Inference request completed with errors");
        }
    }

    public void logModelError(Exception error, String context) {
        MDC.put("errorType", error.getClass().getSimpleName());
        MDC.put("context", context);

        structuredLogger.error("Model operation failed", error);
    }

    @AfterReturning
    public void clearMDC() {
        MDC.clear();
    }
}
```

---

è¿™äº›æœ€ä½³å®è·µå’Œè®¾è®¡æ¨¡å¼å¯ä»¥å¸®åŠ©å¼€å‘è€…æ„å»ºé«˜è´¨é‡ã€å¯ç»´æŠ¤ã€é«˜æ€§èƒ½çš„Java AIåº”ç”¨ç³»ç»Ÿã€‚é€šè¿‡éµå¾ªè¿™äº›æŒ‡å¯¼åŸåˆ™ï¼Œå¯ä»¥æ˜¾è‘—æå‡ä»£ç è´¨é‡å’Œç³»ç»Ÿå¯é æ€§ã€‚