# 泛型在类型安全的AI算法中的应用

## 题目1: ⭐⭐ 泛型在机器学习模型类型安全中的应用

**问题描述**:
在构建机器学习框架时，不同算法可能处理不同类型的数据(数值型、类别型、文本型等)。请设计一个泛型的MachineLearningModel接口，确保类型安全，并支持多种数据类型的训练和预测。

**答案要点**:
- **类型参数设计**: 输入类型、输出类型、特征类型
- **类型安全**: 编译时类型检查，避免运行时类型转换错误
- **泛型约束**: 限制类型参数范围
- **通配符使用**: 灵活处理不同类型

**代码示例**:
```java
// 泛型机器学习模型接口
public interface MachineLearningModel<I, O, F> {
    void train(List<TrainingSample<I, O>> samples);
    O predict(I input);
    List<F> extractFeatures(I input);
    void updateModel(List<TrainingSample<I, O>> newSamples);
}

// 训练样本类型
public class TrainingSample<I, O> {
    private final I input;
    private final O expectedOutput;

    public TrainingSample(I input, O expectedOutput) {
        this.input = input;
        this.expectedOutput = expectedOutput;
    }

    // Getters...
}

// 具体实现: 线性回归模型
public class LinearRegressionModel implements MachineLearningModel<double[], Double, Double> {
    private double[] weights;
    private double bias;

    @Override
    public void train(List<TrainingSample<double[], Double>> samples) {
        // 实现线性回归训练逻辑
        int featureCount = samples.get(0).getInput().length;
        weights = new double[featureCount];
        // 训练算法实现...
    }

    @Override
    public Double predict(double[] input) {
        double result = bias;
        for (int i = 0; i < weights.length; i++) {
            result += weights[i] * input[i];
        }
        return result;
    }

    @Override
    public List<Double> extractFeatures(double[] input) {
        return Arrays.stream(input).boxed().collect(Collectors.toList());
    }
}
```

---

## 题目2: ⭐⭐⭐ 泛型在神经网络层设计中的应用

**问题描述**:
设计一个灵活的神经网络层接口，支持不同数据类型(float、double)的张量操作，并确保类型安全。请实现一个泛型的Layer接口和几个具体的层实现。

**答案要点**:
- **张量类型**: 泛型T表示数值类型(Float, Double)
- **维度处理**: 多维数组类型安全
- **操作接口**: 前向传播、反向传播
- **参数类型**: 权重和偏置的类型安全

**代码示例**:
```java
// 数值类型约束
public interface NumberType<T> extends Comparable<T> {
    T add(T other);
    T multiply(T other);
    T divide(T other);
    T zero();
    T one();
}

// 泛型张量类
public class Tensor<T extends NumberType<T>> {
    private final int[] shape;
    private final T[] data;
    private final int[] strides;

    @SuppressWarnings("unchecked")
    public Tensor(int[] shape, T zero) {
        this.shape = shape.clone();
        this.strides = calculateStrides(shape);
        int totalSize = Arrays.stream(shape).reduce(1, (a, b) -> a * b);
        this.data = (T[]) new Object[totalSize];
        Arrays.fill(this.data, zero);
    }

    private int[] calculateStrides(int[] shape) {
        int[] strides = new int[shape.length];
        int stride = 1;
        for (int i = shape.length - 1; i >= 0; i--) {
            strides[i] = stride;
            stride *= shape[i];
        }
        return strides;
    }

    public T get(int... indices) {
        int flatIndex = calculateFlatIndex(indices);
        return data[flatIndex];
    }

    public void set(T value, int... indices) {
        int flatIndex = calculateFlatIndex(indices);
        data[flatIndex] = value;
    }

    private int calculateFlatIndex(int[] indices) {
        int index = 0;
        for (int i = 0; i < indices.length; i++) {
            index += indices[i] * strides[i];
        }
        return index;
    }

    // 张量操作方法...
    public Tensor<T> add(Tensor<T> other) {
        // 实现张量加法
        return this;
    }

    public Tensor<T> multiply(Tensor<T> other) {
        // 实现张量乘法
        return this;
    }
}

// 泛型层接口
public interface Layer<T extends NumberType<T>, I extends Tensor<T>, O extends Tensor<T>> {
    O forward(I input);
    I backward(O gradient);
    void updateWeights(T learningRate);
    List<Parameter<T>> getParameters();
}

// 全连接层实现
public class DenseLayer<T extends NumberType<T>>
    implements Layer<T, Tensor<T>, Tensor<T>> {

    private Tensor<T> weights;
    private Tensor<T> bias;
    private Tensor<T> lastInput;

    public DenseLayer(int inputSize, int outputSize, T zero) {
        this.weights = new Tensor<>(new int[]{inputSize, outputSize}, zero);
        this.bias = new Tensor<>(new int[]{1, outputSize}, zero);
    }

    @Override
    public Tensor<T> forward(Tensor<T> input) {
        this.lastInput = input;
        // 实现矩阵乘法: input * weights + bias
        return matmul(input, weights).add(bias);
    }

    @Override
    public Tensor<T> backward(Tensor<T> gradient) {
        // 实现反向传播
        Tensor<T> inputGradient = matmul(gradient, transpose(weights));
        Tensor<T> weightGradient = matmul(transpose(lastInput), gradient);

        // 更新权重
        weights = weights.subtract(weightGradient);
        return inputGradient;
    }

    @Override
    public void updateWeights(T learningRate) {
        // 参数更新逻辑
    }

    @Override
    public List<Parameter<T>> getParameters() {
        return Arrays.asList(new Parameter<>("weights", weights),
                           new Parameter<>("bias", bias));
    }

    // 辅助方法...
    private Tensor<T> matmul(Tensor<T> a, Tensor<T> b) {
        // 矩阵乘法实现
        return a;
    }

    private Tensor<T> transpose(Tensor<T> tensor) {
        // 转置实现
        return tensor;
    }

    private Tensor<T> subtract(Tensor<T> other) {
        // 减法实现
        return this;
    }
}

// 参数封装类
public class Parameter<T extends NumberType<T>> {
    private final String name;
    private final Tensor<T> value;

    public Parameter(String name, Tensor<T> value) {
        this.name = name;
        this.value = value;
    }

    // Getters...
}
```

---

## 题目3: ⭐⭐⭐ 泛型在数据管道类型安全中的应用

**问题描述**:
在构建AI数据处理管道时，需要在不同处理阶段之间传递数据，同时保证类型安全。请设计一个泛型的Pipeline系统，支持链式操作和类型检查。

**答案要点**:
- **流式处理**: 类型安全的数据流
- **函数式接口**: 泛型的处理函数
- **类型推导**: 自动类型推导
- **异常处理**: 类型安全的异常处理

**代码示例**:
```java
// 泛型处理函数接口
@FunctionalInterface
public interface Processor<I, O> {
    O process(I input) throws ProcessingException;
}

// 泛型数据管道
public class Pipeline<I, O> {
    private final List<Processor<?, ?>> processors = new ArrayList<>();
    private final Class<I> inputType;
    private final Class<O> outputType;

    public Pipeline(Class<I> inputType, Class<O> outputType) {
        this.inputType = inputType;
        this.outputType = outputType;
    }

    @SuppressWarnings("unchecked")
    public <T> Pipeline<I, T> addProcessor(Processor<O, T> processor) {
        processors.add(processor);
        return (Pipeline<I, T>) this;
    }

    @SuppressWarnings("unchecked")
    public <T> Pipeline<I, T> addProcessor(Function<O, T> function) {
        Processor<O, T> processor = input -> {
            try {
                return function.apply(input);
            } catch (Exception e) {
                throw new ProcessingException("处理失败", e);
            }
        };
        processors.add(processor);
        return (Pipeline<I, T>) this;
    }

    public O execute(I input) throws ProcessingException {
        Object current = input;

        try {
            for (Processor<?, ?> processor : processors) {
                current = ((Processor<Object, Object>) processor).process(current);
            }
            return outputType.cast(current);
        } catch (ClassCastException e) {
            throw new ProcessingException("类型转换失败: 期望 " + outputType.getName(), e);
        }
    }

    // 并行处理
    public CompletableFuture<O> executeAsync(I input) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                return execute(input);
            } catch (ProcessingException e) {
                throw new RuntimeException(e);
            }
        });
    }
}

// 处理异常类
public class ProcessingException extends Exception {
    public ProcessingException(String message) {
        super(message);
    }

    public ProcessingException(String message, Throwable cause) {
        super(message, cause);
    }
}

// 具体处理器实现
public class DataProcessors {
    // 数据清洗处理器
    public static class DataCleaner implements Processor<String, List<String[]>> {
        @Override
        public List<String[]> process(String rawData) throws ProcessingException {
            try {
                return Arrays.stream(rawData.split("\n"))
                    .filter(line -> !line.trim().isEmpty())
                    .map(line -> line.split(","))
                    .collect(Collectors.toList());
            } catch (Exception e) {
                throw new ProcessingException("数据清洗失败", e);
            }
        }
    }

    // 特征提取处理器
    public static class FeatureExtractor implements Processor<List<String[]>, List<double[]>> {
        private final int[] featureIndices;

        public FeatureExtractor(int[] featureIndices) {
            this.featureIndices = featureIndices;
        }

        @Override
        public List<double[]> process(List<String[]> data) throws ProcessingException {
            try {
                return data.stream()
                    .map(row -> {
                        double[] features = new double[featureIndices.length];
                        for (int i = 0; i < featureIndices.length; i++) {
                            int index = featureIndices[i];
                            if (index < row.length) {
                                features[i] = Double.parseDouble(row[index]);
                            } else {
                                features[i] = 0.0;
                            }
                        }
                        return features;
                    })
                    .collect(Collectors.toList());
            } catch (NumberFormatException e) {
                throw new ProcessingException("特征提取失败: 数值格式错误", e);
            }
        }
    }

    // 数据标准化处理器
    public static class DataNormalizer implements Processor<List<double[]>, List<double[]>> {
        @Override
        public List<double[]> process(List<double[]> data) throws ProcessingException {
            if (data.isEmpty()) {
                return data;
            }

            int featureCount = data.get(0).length;
            double[] means = new double[featureCount];
            double[] stds = new double[featureCount];

            // 计算均值
            for (double[] sample : data) {
                for (int i = 0; i < featureCount; i++) {
                    means[i] += sample[i];
                }
            }
            for (int i = 0; i < featureCount; i++) {
                means[i] /= data.size();
            }

            // 计算标准差
            for (double[] sample : data) {
                for (int i = 0; i < featureCount; i++) {
                    double diff = sample[i] - means[i];
                    stds[i] += diff * diff;
                }
            }
            for (int i = 0; i < featureCount; i++) {
                stds[i] = Math.sqrt(stds[i] / data.size());
            }

            // 标准化
            return data.stream()
                .map(sample -> {
                    double[] normalized = new double[featureCount];
                    for (int i = 0; i < featureCount; i++) {
                        normalized[i] = (sample[i] - means[i]) / (stds[i] + 1e-8);
                    }
                    return normalized;
                })
                .collect(Collectors.toList());
        }
    }
}

// 使用示例
public class PipelineExample {
    public static void main(String[] args) {
        String rawData = "1.0,2.0,3.0\n4.0,5.0,6.0\n7.0,8.0,9.0";

        Pipeline<String, List<double[]>> pipeline = new Pipeline<>(String.class, List.class)
            .addProcessor(new DataProcessors.DataCleaner())
            .addProcessor(new DataProcessors.FeatureExtractor(new int[]{0, 1}))
            .addProcessor(new DataProcessors.DataNormalizer());

        try {
            List<double[]> processedData = pipeline.execute(rawData);
            System.out.println("处理后的数据: " + processedData.size() + " 样本");
        } catch (ProcessingException e) {
            System.err.println("数据处理失败: " + e.getMessage());
        }
    }
}
```

---

## 题目4: ⭐⭐⭐⭐ 泛型在模型评估框架中的应用

**问题描述**:
构建一个通用的模型评估框架，支持不同类型的机器学习模型评估指标，如分类、回归、聚类等。请设计泛型的评估接口和具体指标实现。

**答案要点**:
- **泛型约束**: 模型类型、预测类型、真实标签类型
- **指标接口**: 通用的评估指标接口
- **组合指标**: 支持多指标综合评估
- **类型安全**: 避免指标和模型类型不匹配

**代码示例**:
```java
// 泛型评估指标接口
public interface EvaluationMetric<T, P, L> {
    double calculate(List<PredictedValue<P>> predictions, List<TrueValue<L>> trueValues);
    String getName();
    boolean isHigherBetter();
}

// 预测值和真实值封装
public class PredictedValue<T> {
    private final T value;
    private final double confidence;

    public PredictedValue(T value, double confidence) {
        this.value = value;
        this.confidence = confidence;
    }

    public T getValue() { return value; }
    public double getConfidence() { return confidence; }
}

public class TrueValue<T> {
    private final T value;

    public TrueValue(T value) {
        this.value = value;
    }

    public T getValue() { return value; }
}

// 分类准确率指标
public class AccuracyMetric implements EvaluationMetric<Object, Object, Object> {
    @Override
    public double calculate(List<PredictedValue<Object>> predictions,
                           List<TrueValue<Object>> trueValues) {
        if (predictions.size() != trueValues.size()) {
            throw new IllegalArgumentException("预测值和真实值数量不匹配");
        }

        int correct = 0;
        for (int i = 0; i < predictions.size(); i++) {
            if (Objects.equals(predictions.get(i).getValue(), trueValues.get(i).getValue())) {
                correct++;
            }
        }

        return (double) correct / predictions.size();
    }

    @Override
    public String getName() { return "Accuracy"; }

    @Override
    public boolean isHigherBetter() { return true; }
}

// 回归均方误差指标
public class MSEMetric implements EvaluationMetric<Double, Double, Double> {
    @Override
    public double calculate(List<PredictedValue<Double>> predictions,
                           List<TrueValue<Double>> trueValues) {
        if (predictions.size() != trueValues.size()) {
            throw new IllegalArgumentException("预测值和真实值数量不匹配");
        }

        double sumSquaredError = 0.0;
        for (int i = 0; i < predictions.size(); i++) {
            double predicted = predictions.get(i).getValue();
            double actual = trueValues.get(i).getValue();
            double error = predicted - actual;
            sumSquaredError += error * error;
        }

        return sumSquaredError / predictions.size();
    }

    @Override
    public String getName() { return "Mean Squared Error"; }

    @Override
    public boolean isHigherBetter() { return false; }
}

// F1分数指标(多分类)
public class F1Metric implements EvaluationMetric<String, String, String> {
    private final String positiveClass;

    public F1Metric(String positiveClass) {
        this.positiveClass = positiveClass;
    }

    @Override
    public double calculate(List<PredictedValue<String>> predictions,
                           List<TrueValue<String>> trueValues) {
        int truePositive = 0, falsePositive = 0, falseNegative = 0;

        for (int i = 0; i < predictions.size(); i++) {
            String predicted = predictions.get(i).getValue();
            String actual = trueValues.get(i).getValue();

            if (positiveClass.equals(predicted) && positiveClass.equals(actual)) {
                truePositive++;
            } else if (positiveClass.equals(predicted) && !positiveClass.equals(actual)) {
                falsePositive++;
            } else if (!positiveClass.equals(predicted) && positiveClass.equals(actual)) {
                falseNegative++;
            }
        }

        double precision = truePositive + falsePositive == 0 ? 0 :
                          (double) truePositive / (truePositive + falsePositive);
        double recall = truePositive + falseNegative == 0 ? 0 :
                       (double) truePositive / (truePositive + falseNegative);

        return precision + recall == 0 ? 0 : 2 * precision * recall / (precision + recall);
    }

    @Override
    public String getName() { return "F1 Score (" + positiveClass + ")"; }

    @Override
    public boolean isHigherBetter() { return true; }
}

// 泛型评估器
public class ModelEvaluator<T, P, L> {
    private final List<EvaluationMetric<T, P, L>> metrics = new ArrayList<>();

    public void addMetric(EvaluationMetric<T, P, L> metric) {
        metrics.add(metric);
    }

    public EvaluationResult<T, P, L> evaluate(
            MachineLearningModel<T, P, ?> model,
            List<TrainingSample<T, L>> testSamples) {

        List<PredictedValue<P>> predictions = new ArrayList<>();
        List<TrueValue<L>> trueValues = new ArrayList<>();

        // 生成预测
        for (TrainingSample<T, L> sample : testSamples) {
            P prediction = model.predict(sample.getInput());
            predictions.add(new PredictedValue<>(prediction, 1.0)); // 置信度设为1.0
            trueValues.add(new TrueValue<>(sample.getExpectedOutput()));
        }

        // 计算指标
        Map<String, Double> results = new HashMap<>();
        for (EvaluationMetric<T, P, L> metric : metrics) {
            double score = metric.calculate(predictions, trueValues);
            results.put(metric.getName(), score);
        }

        return new EvaluationResult<>(results);
    }

    // 交叉验证评估
    public EvaluationResult<T, P, L> crossValidate(
            MachineLearningModel<T, P, ?> model,
            List<TrainingSample<T, L>> samples,
            int folds) {

        Collections.shuffle(samples);
        int foldSize = samples.size() / folds;

        Map<String, List<Double>> foldResults = new HashMap<>();

        for (int i = 0; i < folds; i++) {
            int start = i * foldSize;
            int end = (i == folds - 1) ? samples.size() : (i + 1) * foldSize;

            List<TrainingSample<T, L>> trainSamples = new ArrayList<>(samples);
            List<TrainingSample<T, L>> testSamples = new ArrayList<>(trainSamples.subList(start, end));
            trainSamples.removeAll(testSamples);

            // 训练模型
            model.train(trainSamples);

            // 评估
            EvaluationResult<T, P, L> result = evaluate(model, testSamples);

            for (Map.Entry<String, Double> entry : result.getScores().entrySet()) {
                foldResults.computeIfAbsent(entry.getKey(), k -> new ArrayList<>())
                          .add(entry.getValue());
            }
        }

        // 计算平均值
        Map<String, Double> avgResults = new HashMap<>();
        for (Map.Entry<String, List<Double>> entry : foldResults.entrySet()) {
            double avg = entry.getValue().stream()
                .mapToDouble(Double::doubleValue)
                .average()
                .orElse(0.0);
            avgResults.put(entry.getKey() + " (CV)", avg);
        }

        return new EvaluationResult<>(avgResults);
    }
}

// 评估结果封装
public class EvaluationResult<T, P, L> {
    private final Map<String, Double> scores;
    private final long timestamp;

    public EvaluationResult(Map<String, Double> scores) {
        this.scores = new HashMap<>(scores);
        this.timestamp = System.currentTimeMillis();
    }

    public Map<String, Double> getScores() { return Collections.unmodifiableMap(scores); }

    public String getSummary() {
        StringBuilder sb = new StringBuilder();
        sb.append("评估结果 (").append(new Date(timestamp)).append("):\n");

        scores.entrySet().stream()
            .sorted(Map.Entry.comparingByValue(Comparator.reverseOrder()))
            .forEach(entry ->
                sb.append(String.format("  %s: %.4f\n", entry.getKey(), entry.getValue())));

        return sb.toString();
    }
}
```

---

## 题目5: ⭐⭐⭐⭐⭐ 复杂泛型约束在AI框架架构设计中的应用

**问题描述**:
设计一个完整的AI框架架构，需要支持多种类型的模型、数据处理器和评估指标。请设计一套复杂的泛型约束系统，确保框架各组件之间的类型安全性和兼容性。

**答案要点**:
- **类型层次**: 模型、数据、处理器的类型层次关系
- **泛型约束**: 多重边界、通配符、类型推导
- **框架兼容性**: 组件之间的类型兼容检查
- **扩展性**: 支持新类型模型的扩展

**代码示例**:
```java
// 基础类型标记接口
public interface DataType<T> {
    Class<T> getTypeClass();
}

// 数值类型约束
public interface NumericType<T> extends DataType<T>, Comparable<T> {
    T add(T other);
    T subtract(T other);
    T multiply(T other);
    T divide(T other);
    T zero();
    T one();
    T abs();
}

// 具体数值类型实现
public enum NumericTypes implements NumericType<Double> {
    DOUBLE(Double.class);

    private final Class<Double> typeClass;

    NumericTypes(Class<Double> typeClass) {
        this.typeClass = typeClass;
    }

    @Override
    public Class<Double> getTypeClass() { return typeClass; }

    @Override
    public Double add(Double other) { return this + other; }

    @Override
    public Double subtract(Double other) { return this - other; }

    @Override
    public Double multiply(Double other) { return this * other; }

    @Override
    public Double divide(Double other) { return this / other; }

    @Override
    public Double zero() { return 0.0; }

    @Override
    public Double one() { return 1.0; }

    @Override
    public Double abs() { return Math.abs(this); }
}

// 泛型数据接口
public interface Data<D extends DataType<T>, T> {
    D getDataType();
    List<T> getValues();
    int size();
    Data<D, T> subset(int from, int to);
    Data<D, T> shuffle();
}

// 标签类型
public interface LabelType<L> extends DataType<L> {
    boolean isValid(L label);
    Set<L> getAllPossibleValues();
}

// 泛型模型接口
public interface AIModel<D extends DataType<T>, T, L extends LabelType<L>> {
    D getInputDataType();
    L getLabelType();
    void train(Data<D, T> features, Data<?, L> labels);
    List<L> predict(Data<D, T> features);
    double predictProbability(Data<D, T> features, L label);
}

// 泛型评估器接口
public interface Evaluator<M extends AIModel<D, T, L>, D extends DataType<T>, T, L extends LabelType<L>> {
    boolean isCompatible(M model);
    EvaluationMetrics evaluate(M model, Data<D, T> testFeatures, Data<?, L> testLabels);
}

// 评估指标结果
public class EvaluationMetrics {
    private final Map<String, Double> metrics;
    private final long evaluationTime;

    public EvaluationMetrics(Map<String, Double> metrics, long evaluationTime) {
        this.metrics = new HashMap<>(metrics);
        this.evaluationTime = evaluationTime;
    }

    public Double getMetric(String name) { return metrics.get(name); }
    public Map<String, Double> getAllMetrics() { return Collections.unmodifiableMap(metrics); }
    public long getEvaluationTime() { return evaluationTime; }

    public String getSummary() {
        StringBuilder sb = new StringBuilder();
        sb.append("评估指标 (耗时: ").append(evaluationTime).append("ms):\n");
        metrics.forEach((name, value) ->
            sb.append(String.format("  %s: %.4f\n", name, value)));
        return sb.toString();
    }
}

// 具体模型实现: 分类器
public class GenericClassifier
    implements AIModel<NumericTypes, Double, String> {

    private final Map<String, double[]> classPrototypes;
    private String[] classes;
    private int featureCount;

    public GenericClassifier() {
        this.classPrototypes = new HashMap<>();
    }

    @Override
    public NumericTypes getInputDataType() { return NumericTypes.DOUBLE; }

    @Override
    public String getLabelType() {
        return "String"; // 简化实现
    }

    @Override
    public void train(Data<NumericTypes, Double> features, Data<?, String> labels) {
        if (features.size() != labels.size()) {
            throw new IllegalArgumentException("特征和标签数量不匹配");
        }

        // 收集所有类别
        Set<String> classSet = new HashSet<>();
        for (int i = 0; i < labels.size(); i++) {
            classSet.add(labels.getValues().get(i));
        }
        this.classes = classSet.toArray(new String[0]);

        // 计算每个类别的原型向量
        this.featureCount = features.getValues().get(0).intValue(); // 简化

        for (String className : classes) {
            double[] prototype = new double[featureCount];
            int count = 0;

            for (int i = 0; i < labels.size(); i++) {
                if (className.equals(labels.getValues().get(i))) {
                    // 累加特征向量
                    for (int j = 0; j < featureCount; j++) {
                        prototype[j] += features.getValues().get(i * featureCount + j);
                    }
                    count++;
                }
            }

            // 计算平均值
            for (int j = 0; j < featureCount; j++) {
                prototype[j] /= count;
            }

            classPrototypes.put(className, prototype);
        }
    }

    @Override
    public List<String> predict(Data<NumericTypes, Double> features) {
        List<String> predictions = new ArrayList<>();

        for (int i = 0; i < features.size(); i++) {
            double[] featureVector = extractFeatureVector(features, i);
            String predictedClass = findClosestClass(featureVector);
            predictions.add(predictedClass);
        }

        return predictions;
    }

    @Override
    public double predictProbability(Data<NumericTypes, Double> features, String label) {
        double[] prototype = classPrototypes.get(label);
        if (prototype == null) return 0.0;

        double totalDistance = 0.0;
        double targetDistance = Double.MAX_VALUE;

        for (int i = 0; i < features.size(); i++) {
            double[] featureVector = extractFeatureVector(features, i);

            double distanceToTarget = euclideanDistance(featureVector, prototype);
            targetDistance = Math.min(targetDistance, distanceToTarget);

            double minDistance = Double.MAX_VALUE;
            for (double[] otherPrototype : classPrototypes.values()) {
                minDistance = Math.min(minDistance, euclideanDistance(featureVector, otherPrototype));
            }
            totalDistance += minDistance;
        }

        return targetDistance / (totalDistance + 1e-8);
    }

    private double[] extractFeatureVector(Data<NumericTypes, Double> features, int index) {
        double[] vector = new double[featureCount];
        for (int j = 0; j < featureCount; j++) {
            vector[j] = features.getValues().get(index * featureCount + j);
        }
        return vector;
    }

    private String findClosestClass(double[] featureVector) {
        String bestClass = null;
        double minDistance = Double.MAX_VALUE;

        for (Map.Entry<String, double[]> entry : classPrototypes.entrySet()) {
            double distance = euclideanDistance(featureVector, entry.getValue());
            if (distance < minDistance) {
                minDistance = distance;
                bestClass = entry.getKey();
            }
        }

        return bestClass;
    }

    private double euclideanDistance(double[] a, double[] b) {
        double sum = 0.0;
        for (int i = 0; i < a.length; i++) {
            double diff = a[i] - b[i];
            sum += diff * diff;
        }
        return Math.sqrt(sum);
    }
}

// 具体评估器实现
public class ClassificationEvaluator
    implements Evaluator<AIModel<NumericTypes, Double, String>, NumericTypes, Double, String> {

    @Override
    public boolean isCompatible(AIModel<NumericTypes, Double, String> model) {
        return model.getInputDataType() == NumericTypes.DOUBLE;
    }

    @Override
    public EvaluationMetrics evaluate(AIModel<NumericTypes, Double, String> model,
                                    Data<NumericTypes, Double> testFeatures,
                                    Data<?, String> testLabels) {
        long startTime = System.currentTimeMillis();

        List<String> predictions = model.predict(testFeatures);
        Map<String, Double> metrics = new HashMap<>();

        // 计算准确率
        int correct = 0;
        for (int i = 0; i < predictions.size(); i++) {
            if (predictions.get(i).equals(testLabels.getValues().get(i))) {
                correct++;
            }
        }
        metrics.put("accuracy", (double) correct / predictions.size());

        // 计算每个类别的F1分数
        Set<String> classes = new HashSet<>(testLabels.getValues());
        for (String className : classes) {
            double f1 = calculateF1Score(predictions, testLabels.getValues(), className);
            metrics.put("f1_" + className, f1);
        }

        // 计算宏平均F1
        double macroF1 = classes.stream()
            .mapToDouble(className -> calculateF1Score(predictions, testLabels.getValues(), className))
            .average()
            .orElse(0.0);
        metrics.put("macro_f1", macroF1);

        long endTime = System.currentTimeMillis();
        return new EvaluationMetrics(metrics, endTime - startTime);
    }

    private double calculateF1Score(List<String> predictions, List<String> trueLabels, String className) {
        int tp = 0, fp = 0, fn = 0;

        for (int i = 0; i < predictions.size(); i++) {
            String predicted = predictions.get(i);
            String actual = trueLabels.get(i);

            if (className.equals(predicted) && className.equals(actual)) {
                tp++;
            } else if (className.equals(predicted) && !className.equals(actual)) {
                fp++;
            } else if (!className.equals(predicted) && className.equals(actual)) {
                fn++;
            }
        }

        double precision = tp + fp == 0 ? 0 : (double) tp / (tp + fp);
        double recall = tp + fn == 0 ? 0 : (double) tp / (tp + fn);
        return precision + recall == 0 ? 0 : 2 * precision * recall / (precision + recall);
    }
}

// 框架工厂类
public class AIFramework {
    public static <D extends DataType<T>, T, L extends LabelType<L>>
            ModelBuilder<D, T, L> modelBuilder(D dataType, L labelType) {
        return new ModelBuilder<>(dataType, labelType);
    }

    public static class ModelBuilder<D extends DataType<T>, T, L extends LabelType<L>> {
        private final D dataType;
        private final L labelType;

        private ModelBuilder(D dataType, L labelType) {
            this.dataType = dataType;
            this.labelType = labelType;
        }

        public AIModel<D, T, L> buildClassifier(String algorithm) {
            if (dataType == NumericTypes.DOUBLE && labelType.equals("String")) {
                @SuppressWarnings("unchecked")
                AIModel<D, T, L> model = (AIModel<D, T, L>) new GenericClassifier();
                return model;
            }
            throw new UnsupportedOperationException("不支持的模型类型组合");
        }

        public Evaluator<AIModel<D, T, L>, D, T, L> buildEvaluator() {
            if (dataType == NumericTypes.DOUBLE && labelType.equals("String")) {
                @SuppressWarnings("unchecked")
                Evaluator<AIModel<D, T, L>, D, T, L> evaluator =
                    (Evaluator<AIModel<D, T, L>, D, T, L>) new ClassificationEvaluator();
                return evaluator;
            }
            throw new UnsupportedOperationException("不支持的评估器类型组合");
        }
    }
}
```

---

**总结**: Java泛型在AI算法开发中提供了强大的类型安全机制，从基础的数据处理到复杂的模型评估都能发挥重要作用。合理设计泛型约束和类型层次结构，可以构建出既灵活又安全的AI框架架构。