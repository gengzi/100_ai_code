# AI模型数据的加密与解密技术

## 题目1: ⭐⭐ Java加密技术在AI模型文件保护中的应用

**问题描述**:
AI训练完成后生成的模型文件包含了大量有价值的知识产权信息。请设计一个完整的Java解决方案来保护AI模型文件，包括文件加密、密钥管理和访问控制。

**答案要点**:
- **加密算法选择**: AES-256、RSA混合加密
- **密钥管理**: 密钥生成、存储、轮换机制
- **访问控制**: 基于角色的权限管理
- **完整性验证**: 数字签名防止篡改

**代码示例**:
```java
public class ModelFileProtector {
    private static final String AES_ALGORITHM = "AES/CBC/PKCS5Padding";
    private static final String RSA_ALGORITHM = "RSA/ECB/OAEPWithSHA-256AndMGF1Padding";
    private static final int AES_KEY_SIZE = 256;
    private static final int RSA_KEY_SIZE = 2048;

    private final KeyStore keyStore;
    private final String keyStorePassword;

    public ModelFileProtector(String keyStorePath, String keyStorePassword) throws Exception {
        this.keyStorePassword = keyStorePassword;
        this.keyStore = loadKeyStore(keyStorePath, keyStorePassword);
    }

    public void protectModelFile(File modelFile, String alias, String accessRole) throws Exception {
        // 生成随机AES密钥
        SecretKey aesKey = generateAESKey();

        // 使用AES加密模型文件
        byte[] encryptedData = encryptWithAES(modelFile, aesKey);

        // 使用RSA公钥加密AES密钥
        PublicKey publicKey = keyStore.getCertificate(alias).getPublicKey();
        byte[] encryptedAESKey = encryptWithRSA(aesKey.getEncoded(), publicKey);

        // 创建受保护的模型文件
        ProtectedModelFile protectedModel = new ProtectedModelFile(
            encryptedData,
            encryptedAESKey,
            calculateFileHash(modelFile),
            accessRole,
            System.currentTimeMillis()
        );

        // 保存受保护的模型文件
        String protectedPath = modelFile.getPath() + ".protected";
        serializeProtectedModel(protectedModel, new File(protectedPath));
    }

    public File decryptModelFile(File protectedFile, String alias, String userRole) throws Exception {
        // 验证访问权限
        if (!hasAccessPermission(userRole, alias)) {
            throw new SecurityException("无权访问该模型文件");
        }

        // 加载受保护的模型文件
        ProtectedModelFile protectedModel = deserializeProtectedModel(protectedFile);

        // 使用RSA私钥解密AES密钥
        PrivateKey privateKey = (PrivateKey) keyStore.getKey(alias, keyStorePassword.toCharArray());
        byte[] aesKeyBytes = decryptWithRSA(protectedModel.getEncryptedAESKey(), privateKey);
        SecretKey aesKey = new SecretKeySpec(aesKeyBytes, "AES");

        // 使用AES密钥解密模型数据
        byte[] decryptedData = decryptWithAES(protectedModel.getEncryptedData(), aesKey, protectedModel);

        // 验证文件完整性
        if (!verifyFileIntegrity(decryptedData, protectedModel.getOriginalHash())) {
            throw new SecurityException("模型文件已被篡改或损坏");
        }

        // 保存解密后的模型文件
        String decryptedPath = protectedFile.getPath().replace(".protected", ".decrypted");
        Files.write(Paths.get(decryptedPath), decryptedData);
        return new File(decryptedPath);
    }

    private SecretKey generateAESKey() throws NoSuchAlgorithmException {
        KeyGenerator keyGenerator = KeyGenerator.getInstance("AES");
        keyGenerator.init(AES_KEY_SIZE);
        return keyGenerator.generateKey();
    }

    private byte[] encryptWithAES(File file, SecretKey aesKey) throws Exception {
        Cipher cipher = Cipher.getInstance(AES_ALGORITHM);

        // 生成随机IV
        byte[] iv = new byte[16];
        new SecureRandom().nextBytes(iv);

        IvParameterSpec ivSpec = new IvParameterSpec(iv);
        cipher.init(Cipher.ENCRYPT_MODE, aesKey, ivSpec);

        byte[] fileData = Files.readAllBytes(file.toPath());
        byte[] encryptedData = cipher.doFinal(fileData);

        // 将IV和加密数据合并
        byte[] result = new byte[iv.length + encryptedData.length];
        System.arraycopy(iv, 0, result, 0, iv.length);
        System.arraycopy(encryptedData, 0, result, iv.length, encryptedData.length);

        return result;
    }

    private byte[] decryptWithAES(byte[] encryptedData, SecretKey aesKey, ProtectedModelFile protectedModel) throws Exception {
        Cipher cipher = Cipher.getInstance(AES_ALGORITHM);

        // 提取IV
        byte[] iv = new byte[16];
        System.arraycopy(encryptedData, 0, iv, 0, iv.length);
        IvParameterSpec ivSpec = new IvParameterSpec(iv);

        // 提取加密数据
        byte[] actualEncryptedData = new byte[encryptedData.length - 16];
        System.arraycopy(encryptedData, 16, actualEncryptedData, 0, actualEncryptedData.length);

        cipher.init(Cipher.DECRYPT_MODE, aesKey, ivSpec);
        return cipher.doFinal(actualEncryptedData);
    }

    private byte[] encryptWithRSA(byte[] data, PublicKey publicKey) throws Exception {
        Cipher cipher = Cipher.getInstance(RSA_ALGORITHM);
        cipher.init(Cipher.ENCRYPT_MODE, publicKey);
        return cipher.doFinal(data);
    }

    private byte[] decryptWithRSA(byte[] encryptedData, PrivateKey privateKey) throws Exception {
        Cipher cipher = Cipher.getInstance(RSA_ALGORITHM);
        cipher.init(Cipher.DECRYPT_MODE, privateKey);
        return cipher.doFinal(encryptedData);
    }

    private String calculateFileHash(File file) throws Exception {
        MessageDigest digest = MessageDigest.getInstance("SHA-256");
        byte[] fileBytes = Files.readAllBytes(file.toPath());
        byte[] hashBytes = digest.digest(fileBytes);
        return Base64.getEncoder().encodeToString(hashBytes);
    }

    private boolean verifyFileIntegrity(byte[] decryptedData, String originalHash) throws Exception {
        MessageDigest digest = MessageDigest.getInstance("SHA-256");
        byte[] currentHashBytes = digest.digest(decryptedData);
        String currentHash = Base64.getEncoder().encodeToString(currentHashBytes);
        return currentHash.equals(originalHash);
    }

    private boolean hasAccessPermission(String userRole, String alias) {
        // 实现基于角色的访问控制逻辑
        return true; // 简化实现
    }

    private KeyStore loadKeyStore(String path, String password) throws Exception {
        KeyStore ks = KeyStore.getInstance("PKCS12");
        try (InputStream is = Files.newInputStream(Paths.get(path))) {
            ks.load(is, password.toCharArray());
        }
        return ks;
    }

    private void serializeProtectedModel(ProtectedModelFile model, File file) throws Exception {
        try (ObjectOutputStream oos = new ObjectOutputStream(
             new FileOutputStream(file))) {
            oos.writeObject(model);
        }
    }

    private ProtectedModelFile deserializeProtectedModel(File file) throws Exception {
        try (ObjectInputStream ois = new ObjectInputStream(
             new FileInputStream(file))) {
            return (ProtectedModelFile) ois.readObject();
        }
    }

    // 受保护模型文件的数据结构
    private static class ProtectedModelFile implements Serializable {
        private final byte[] encryptedData;
        private final byte[] encryptedAESKey;
        private final String originalHash;
        private final String accessRole;
        private final long timestamp;

        public ProtectedModelFile(byte[] encryptedData, byte[] encryptedAESKey,
                                String originalHash, String accessRole, long timestamp) {
            this.encryptedData = encryptedData;
            this.encryptedAESKey = encryptedAESKey;
            this.originalHash = originalHash;
            this.accessRole = accessRole;
            this.timestamp = timestamp;
        }

        // Getters...
        public byte[] getEncryptedData() { return encryptedData; }
        public byte[] getEncryptedAESKey() { return encryptedAESKey; }
        public String getOriginalHash() { return originalHash; }
        public String getAccessRole() { return accessRole; }
        public long getTimestamp() { return timestamp; }
    }
}
```

---

## 题目2: ⭐⭐⭐ AI模型推理过程的数据保护

**问题描述**:
在AI模型推理过程中，输入数据和预测结果可能包含敏感信息。请设计一个Java方案来保护推理过程中的数据安全，包括输入数据脱敏、推理链路加密和结果安全返回。

**答案要点**:
- **数据脱敏**: 敏感信息识别和替换
- **传输加密**: TLS/SSL通信安全
- **内存安全**: 敏感数据及时清理
- **审计日志**: 操作记录和追踪

**代码示例**:
```java
public class SecureInferenceService {
    private static final String[] SENSITIVE_PATTERNS = {
        "\\b\\d{4}[-\\s]?\\d{4}[-\\s]?\\d{4}[-\\s]?\\d{4}\\b", // 信用卡号
        "\\b\\d{3}-\\d{2}-\\d{4}\\b", // 社保号
        "\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b" // 邮箱
    };

    private final ModelFileProtector modelProtector;
    private final DataMasker dataMasker;
    private final SecureRandom secureRandom;

    public SecureInferenceService(ModelFileProtector modelProtector) {
        this.modelProtector = modelProtector;
        this.dataMasker = new DataMasker();
        this.secureRandom = new SecureRandom();
    }

    public SecureInferenceResult performSecureInference(
            SecureInferenceRequest request, String modelAlias) throws Exception {

        // 验证请求权限
        if (!validateRequestPermission(request)) {
            throw new SecurityException("无权限执行模型推理");
        }

        // 数据脱敏处理
        String maskedInput = dataMasker.maskSensitiveData(request.getInputData());

        // 记录审计日志
        logAuditEntry("INFERENCE_REQUEST", request.getClientId(),
                     request.getModelId(), maskedInput);

        // 加载并解密模型
        File protectedModel = new File(request.getModelPath() + ".protected");
        File decryptedModel = modelProtector.decryptModelFile(
            protectedModel, modelAlias, request.getUserRole());

        try {
            // 执行推理
            String inferenceResult = performInference(decryptedModel, maskedInput);

            // 结果数据保护处理
            String protectedResult = protectInferenceResult(inferenceResult, request);

            // 清理敏感内存
            clearSensitiveMemory(maskedInput.getBytes());

            // 记录推理结果日志
            logAuditEntry("INFERENCE_RESULT", request.getClientId(),
                         request.getModelId(), "SUCCESS");

            return new SecureInferenceResult(protectedResult, true, null);

        } finally {
            // 确保模型文件被清理
            decryptedModel.delete();
        }
    }

    private boolean validateRequestPermission(SecureInferenceRequest request) {
        // 验证请求签名、令牌等
        return request.getSignature() != null &&
               request.getTimestamp() > System.currentTimeMillis() - 300000; // 5分钟有效期
    }

    private String performInference(File modelFile, String inputData) throws Exception {
        // 实际的AI推理逻辑
        // 这里应该是调用具体的AI模型推理引擎
        return "inference_result_" + secureRandom.nextInt(10000);
    }

    private String protectInferenceResult(String result, SecureInferenceRequest request) {
        // 根据请求方权限级别决定结果保护程度
        if ("HIGH".equals(request.getSecurityLevel())) {
            // 高安全级别：部分结果隐藏
            return "PROTECTED: " + result.hashCode();
        } else if ("MEDIUM".equals(request.getSecurityLevel())) {
            // 中等安全级别：结果哈希化
            return DigestUtils.sha256Hex(result);
        } else {
            // 低安全级别：完整结果
            return result;
        }
    }

    private void clearSensitiveMemory(byte[] sensitiveData) {
        // 清理敏感数据内存
        Arrays.fill(sensitiveData, (byte) 0);
    }

    private void logAuditEntry(String action, String clientId, String modelId, String details) {
        // 记录审计日志
        AuditLogEntry entry = new AuditLogEntry(
            action, clientId, modelId, details, System.currentTimeMillis()
        );
        // 保存到审计日志系统
        AuditLogger.log(entry);
    }

    // 数据脱敏器
    private static class DataMasker {
        public String maskSensitiveData(String data) {
            String masked = data;

            for (String pattern : SENSITIVE_PATTERNS) {
                masked = masked.replaceAll(pattern, "[REDACTED]");
            }

            return masked;
        }

        public String unmaskData(String maskedData, String maskingKey) {
            // 实现数据恢复逻辑（如果有需要）
            return maskedData;
        }
    }

    // 安全推理请求
    public static class SecureInferenceRequest implements Serializable {
        private final String clientId;
        private final String modelId;
        private final String modelPath;
        private final String inputData;
        private final String userRole;
        private final String securityLevel;
        private final String signature;
        private final long timestamp;

        public SecureInferenceRequest(String clientId, String modelId, String modelPath,
                                    String inputData, String userRole, String securityLevel,
                                    String signature) {
            this.clientId = clientId;
            this.modelId = modelId;
            this.modelPath = modelPath;
            this.inputData = inputData;
            this.userRole = userRole;
            this.securityLevel = securityLevel;
            this.signature = signature;
            this.timestamp = System.currentTimeMillis();
        }

        // Getters...
        public String getClientId() { return clientId; }
        public String getModelId() { return modelId; }
        public String getModelPath() { return modelPath; }
        public String getInputData() { return inputData; }
        public String getUserRole() { return userRole; }
        public String getSecurityLevel() { return securityLevel; }
        public String getSignature() { return signature; }
        public long getTimestamp() { return timestamp; }
    }

    // 安全推理结果
    public static class SecureInferenceResult implements Serializable {
        private final String result;
        private final boolean success;
        private final String errorMessage;

        public SecureInferenceResult(String result, boolean success, String errorMessage) {
            this.result = result;
            this.success = success;
            this.errorMessage = errorMessage;
        }

        // Getters...
        public String getResult() { return result; }
        public boolean isSuccess() { return success; }
        public String getErrorMessage() { return errorMessage; }
    }
}
```

---

## 题目3: ⭐⭐⭐⭐ 基于区块链的AI模型版权保护

**问题描述**:
AI模型的版权保护是知识产权的重要问题。请设计一个基于区块链技术的Java解决方案来保护AI模型的版权，包括模型指纹生成、版权注册和侵权检测。

**答案要点**:
- **模型指纹**: 唯一标识模型特征
- **区块链存储**: 不可篡改的版权记录
- **水印技术**: 在模型中嵌入版权信息
- **智能合约**: 自动化的版权保护机制

**代码示例**:
```java
public class BlockchainModelProtection {
    private final BlockchainService blockchainService;
    private final ModelFingerprinter fingerprinter;
    private final ModelWatermarker watermarker;

    public BlockchainModelProtection(BlockchainService blockchainService) {
        this.blockchainService = blockchainService;
        this.fingerprinter = new ModelFingerprinter();
        this.watermarker = new ModelWatermarker();
    }

    public CopyrightRegistration protectModelCopyright(
            File modelFile, ModelMetadata metadata) throws Exception {

        // 生成模型指纹
        ModelFingerprint fingerprint = fingerprinter.generateFingerprint(modelFile);

        // 在模型中嵌入版权水印
        File watermarkedModel = watermarker.embedWatermark(modelFile, metadata.getOwnerId());

        // 创建版权记录
        CopyrightRecord record = new CopyrightRecord(
            metadata.getModelId(),
            metadata.getOwnerId(),
            fingerprint,
            System.currentTimeMillis(),
            metadata.getDescription()
        );

        // 将版权记录注册到区块链
        String transactionHash = blockchainService.registerCopyright(record);

        return new CopyrightRegistration(watermarkedModel, transactionHash, record);
    }

    public CopyrightVerification verifyModelCopyright(File modelFile, String modelId) throws Exception {
        // 从区块链获取版权记录
        CopyrightRecord record = blockchainService.getCopyrightRecord(modelId);
        if (record == null) {
            return new CopyrightVerification(false, "未找到版权记录", null);
        }

        // 生成当前模型的指纹
        ModelFingerprint currentFingerprint = fingerprinter.generateFingerprint(modelFile);

        // 比较指纹
        double similarity = fingerprinter.compareFingerprints(record.getFingerprint(), currentFingerprint);

        if (similarity > 0.95) {
            // 检查水印
            String watermarkOwnerId = watermarker.extractWatermark(modelFile);
            boolean watermarkValid = metadata.getOwnerId().equals(watermarkOwnerId);

            return new CopyrightVerification(true, "版权验证通过", record);
        } else {
            return new CopyrightVerification(false,
                "模型指纹不匹配，可能存在侵权", record);
        }
    }

    public List<PotentialInfringement> detectInfringements(File modelFile) throws Exception {
        List<PotentialInfringement> infringements = new ArrayList<>();

        // 生成查询模型的指纹
        ModelFingerprint queryFingerprint = fingerprinter.generateFingerprint(modelFile);

        // 从区块链获取所有已注册的版权记录
        List<CopyrightRecord> allRecords = blockchainService.getAllCopyrightRecords();

        // 检查相似性
        for (CopyrightRecord record : allRecords) {
            double similarity = fingerprinter.compareFingerprints(record.getFingerprint(), queryFingerprint);

            if (similarity > 0.90 && similarity < 0.95) {
                infringements.add(new PotentialInfringement(
                    record.getModelId(),
                    record.getOwnerId(),
                    similarity,
                    "高相似度检测"
                ));
            }
        }

        return infringements;
    }

    // 模型指纹生成器
    private static class ModelFingerprinter {
        public ModelFingerprint generateFingerprint(File modelFile) throws Exception {
            byte[] modelData = Files.readAllBytes(modelFile.toPath());

            // 多种哈希算法组合生成指纹
            MessageDigest sha256 = MessageDigest.getInstance("SHA-256");
            MessageDigest md5 = MessageDigest.getInstance("MD5");

            byte[] sha256Hash = sha256.digest(modelData);
            byte[] md5Hash = md5.digest(modelData);

            // 计算模型特征
            ModelFeatures features = extractModelFeatures(modelData);

            return new ModelFingerprint(
                Base64.getEncoder().encodeToString(sha256Hash),
                Base64.getEncoder().encodeToString(md5Hash),
                features,
                System.currentTimeMillis()
            );
        }

        private ModelFeatures extractModelFeatures(byte[] modelData) {
            // 简化的特征提取
            int size = modelData.length;
            double entropy = calculateEntropy(modelData);

            return new ModelFeatures(size, entropy);
        }

        private double calculateEntropy(byte[] data) {
            int[] frequency = new int[256];
            for (byte b : data) {
                frequency[b & 0xFF]++;
            }

            double entropy = 0.0;
            for (int count : frequency) {
                if (count > 0) {
                    double probability = (double) count / data.length;
                    entropy -= probability * Math.log(probability) / Math.log(2);
                }
            }

            return entropy;
        }

        public double compareFingerprints(ModelFingerprint fp1, ModelFingerprint fp2) {
            // SHA-256完全匹配
            if (fp1.getSha256Hash().equals(fp2.getSha256Hash())) {
                return 1.0;
            }

            // MD5完全匹配
            if (fp1.getMd5Hash().equals(fp2.getMd5Hash())) {
                return 0.98;
            }

            // 特征相似度计算
            double featureSimilarity = compareFeatures(fp1.getFeatures(), fp2.getFeatures());

            return featureSimilarity;
        }

        private double compareFeatures(ModelFeatures f1, ModelFeatures f2) {
            double sizeSimilarity = 1.0 - Math.abs(f1.getSize() - f2.getSize()) /
                                  Math.max(f1.getSize(), f2.getSize());
            double entropySimilarity = 1.0 - Math.abs(f1.getEntropy() - f2.getEntropy());

            return (sizeSimilarity + entropySimilarity) / 2.0;
        }
    }

    // 模型水印器
    private static class ModelWatermarker {
        private static final String WATERMARK_SIGNATURE = "AI_MODEL_COPYRIGHT";

        public File embedWatermark(File modelFile, String ownerId) throws Exception {
            byte[] modelData = Files.readAllBytes(modelFile.toPath());
            byte[] watermark = generateWatermark(ownerId);

            // 在模型数据中嵌入水印（简化实现）
            byte[] watermarkedData = embedWatermarkInData(modelData, watermark);

            String watermarkedPath = modelFile.getPath() + ".watermarked";
            Files.write(Paths.get(watermarkedPath), watermarkedData);

            return new File(watermarkedPath);
        }

        public String extractWatermark(File watermarkedModelFile) throws Exception {
            byte[] modelData = Files.readAllBytes(watermarkedModelFile.toPath());
            return extractWatermarkFromData(modelData);
        }

        private byte[] generateWatermark(String ownerId) {
            String watermarkText = WATERMARK_SIGNATURE + ":" + ownerId + ":" + System.currentTimeMillis();
            return watermarkText.getBytes(StandardCharsets.UTF_8);
        }

        private byte[] embedWatermarkInData(byte[] data, byte[] watermark) {
            byte[] watermarked = Arrays.copyOf(data, data.length);

            // 简化的水印嵌入算法：在特定位置嵌入水印
            int watermarkPos = data.length - watermark.length - 100;
            System.arraycopy(watermark, 0, watermarked, watermarkPos, watermark.length);

            return watermarked;
        }

        private String extractWatermarkFromData(byte[] data) {
            // 查找水印位置
            String dataStr = new String(data, StandardCharsets.UTF_8);
            int watermarkStart = dataStr.indexOf(WATERMARK_SIGNATURE);

            if (watermarkStart != -1) {
                int watermarkEnd = dataStr.indexOf(':', watermarkStart + WATERMARK_SIGNATURE.length() + 1);
                if (watermarkEnd != -1) {
                    return dataStr.substring(watermarkStart + WATERMARK_SIGNATURE.length() + 1, watermarkEnd);
                }
            }

            return null;
        }
    }

    // 数据结构定义
    public static class ModelMetadata implements Serializable {
        private final String modelId;
        private final String ownerId;
        private final String description;

        public ModelMetadata(String modelId, String ownerId, String description) {
            this.modelId = modelId;
            this.ownerId = ownerId;
            this.description = description;
        }

        public String getModelId() { return modelId; }
        public String getOwnerId() { return ownerId; }
        public String getDescription() { return description; }
    }

    public static class ModelFingerprint implements Serializable {
        private final String sha256Hash;
        private final String md5Hash;
        private final ModelFeatures features;
        private final long timestamp;

        public ModelFingerprint(String sha256Hash, String md5Hash, ModelFeatures features, long timestamp) {
            this.sha256Hash = sha256Hash;
            this.md5Hash = md5Hash;
            this.features = features;
            this.timestamp = timestamp;
        }

        public String getSha256Hash() { return sha256Hash; }
        public String getMd5Hash() { return md5Hash; }
        public ModelFeatures getFeatures() { return features; }
        public long getTimestamp() { return timestamp; }
    }

    public static class ModelFeatures implements Serializable {
        private final int size;
        private final double entropy;

        public ModelFeatures(int size, double entropy) {
            this.size = size;
            this.entropy = entropy;
        }

        public int getSize() { return size; }
        public double getEntropy() { return entropy; }
    }

    public static class CopyrightRecord implements Serializable {
        private final String modelId;
        private final String ownerId;
        private final ModelFingerprint fingerprint;
        private final long registrationTime;
        private final String description;

        public CopyrightRecord(String modelId, String ownerId, ModelFingerprint fingerprint,
                             long registrationTime, String description) {
            this.modelId = modelId;
            this.ownerId = ownerId;
            this.fingerprint = fingerprint;
            this.registrationTime = registrationTime;
            this.description = description;
        }

        // Getters...
        public String getModelId() { return modelId; }
        public String getOwnerId() { return ownerId; }
        public ModelFingerprint getFingerprint() { return fingerprint; }
        public long getRegistrationTime() { return registrationTime; }
        public String getDescription() { return description; }
    }

    public static class CopyrightRegistration implements Serializable {
        private final File protectedModel;
        private final String transactionHash;
        private final CopyrightRecord record;

        public CopyrightRegistration(File protectedModel, String transactionHash, CopyrightRecord record) {
            this.protectedModel = protectedModel;
            this.transactionHash = transactionHash;
            this.record = record;
        }

        public File getProtectedModel() { return protectedModel; }
        public String getTransactionHash() { return transactionHash; }
        public CopyrightRecord getRecord() { return record; }
    }

    public static class CopyrightVerification implements Serializable {
        private final boolean valid;
        private final String message;
        private final CopyrightRecord record;

        public CopyrightVerification(boolean valid, String message, CopyrightRecord record) {
            this.valid = valid;
            this.message = message;
            this.record = record;
        }

        public boolean isValid() { return valid; }
        public String getMessage() { return message; }
        public CopyrightRecord getRecord() { return record; }
    }

    public static class PotentialInfringement implements Serializable {
        private final String modelId;
        private final String ownerId;
        private final double similarity;
        private final String reason;

        public PotentialInfringement(String modelId, String ownerId, double similarity, String reason) {
            this.modelId = modelId;
            this.ownerId = ownerId;
            this.similarity = similarity;
            this.reason = reason;
        }

        public String getModelId() { return modelId; }
        public String getOwnerId() { return ownerId; }
        public double getSimilarity() { return similarity; }
        public String getReason() { return reason; }
    }

    // 区块链服务接口（简化实现）
    public interface BlockchainService {
        String registerCopyright(CopyrightRecord record) throws Exception;
        CopyrightRecord getCopyrightRecord(String modelId) throws Exception;
        List<CopyrightRecord> getAllCopyrightRecords() throws Exception;
    }
}
```

---

## 题目4: ⭐⭐⭐⭐⭐ 联邦学习中的安全数据交换机制

**问题描述**:
在联邦学习环境中，多个参与方需要在不直接共享原始数据的情况下协作训练AI模型。请设计一个基于Java的安全数据交换系统，确保数据隐私和模型训练的安全性。

**答案要点**:
- **差分隐私**: 保护个体隐私
- **安全多方计算**: 不暴露原始数据
- **同态加密**: 加密状态下的模型更新
- **梯度验证**: 防止恶意攻击

**代码示例**:
```java
public class FederatedLearningSecurity {
    private static final double EPSILON = 1.0; // 差分隐私预算
    private static final double SENSITIVITY = 1.0; // 数据敏感度
    private final HomomorphicCrypto homomorphicCrypto;
    private final DifferentialPrivacy differentialPrivacy;
    private final SecureAggregator secureAggregator;

    public FederatedLearningSecurity() {
        this.homomorphicCrypto = new PaillierHomomorphicCrypto();
        this.differentialPrivacy = new LaplaceDifferentialPrivacy(EPSILON, SENSITIVITY);
        this.secureAggregator = new SecureAggregator();
    }

    public EncryptedGradient encryptGradient(double[] gradient, String clientId) throws Exception {
        // 1. 应用差分隐私
        double[] privateGradient = differentialPrivacy.addNoise(gradient);

        // 2. 客户端签名
        String signature = signGradient(privateGradient, clientId);

        // 3. 同态加密
        return homomorphicCrypto.encrypt(privateGradient, signature);
    }

    public double[] aggregateGradients(List<EncryptedGradient> encryptedGradients) throws Exception {
        // 1. 验证所有梯度的有效性
        for (EncryptedGradient eg : encryptedGradients) {
            if (!validateGradient(eg)) {
                throw new SecurityException("检测到无效的梯度数据");
            }
        }

        // 2. 同态聚合
        EncryptedGradient aggregatedEncrypted = secureAggregator.aggregate(encryptedGradients);

        // 3. 解密聚合结果
        return homomorphicCrypto.decrypt(aggregatedEncrypted);
    }

    private boolean validateGradient(EncryptedGradient encryptedGradient) {
        // 验证梯度签名、范围等
        return true; // 简化实现
    }

    private String signGradient(double[] gradient, String clientId) throws Exception {
        // 使用客户端私钥签名梯度
        String gradientHash = calculateGradientHash(gradient);
        return SignatureUtils.sign(gradientHash, clientId);
    }

    private String calculateGradientHash(double[] gradient) throws Exception {
        MessageDigest digest = MessageDigest.getInstance("SHA-256");
        StringBuilder sb = new StringBuilder();
        for (double value : gradient) {
            sb.append(value).append(",");
        }
        byte[] hashBytes = digest.digest(sb.toString().getBytes());
        return Base64.getEncoder().encodeToString(hashBytes);
    }

    // 同态加密实现（简化版Paillier算法）
    private static class PaillierHomomorphicCrypto implements HomomorphicCrypto {
        private final KeyPair keyPair;

        public PaillierHomomorphicCrypto() throws Exception {
            this.keyPair = generateKeyPair();
        }

        @Override
        public EncryptedGradient encrypt(double[] gradient, String signature) throws Exception {
            BigInteger[] encryptedValues = new BigInteger[gradient.length];

            for (int i = 0; i < gradient.length; i++) {
                encryptedValues[i] = encryptValue(gradient[i]);
            }

            return new EncryptedGradient(encryptedValues, signature);
        }

        @Override
        public double[] decrypt(EncryptedGradient encryptedGradient) throws Exception {
            BigInteger[] encryptedValues = encryptedGradient.getEncryptedValues();
            double[] decryptedValues = new double[encryptedValues.length];

            for (int i = 0; i < encryptedValues.length; i++) {
                decryptedValues[i] = decryptValue(encryptedValues[i]);
            }

            return decryptedValues;
        }

        private BigInteger encryptValue(double value) throws Exception {
            // 简化的Paillier加密实现
            BigInteger plaintext = BigDecimal.valueOf(value).multiply(BigInteger.valueOf(1000)).toBigInteger();

            // 这里应该是实际的Paillier加密算法
            // 简化实现：返回一个"加密"的值
            return plaintext.add(BigInteger.valueOf(123456789L));
        }

        private double decryptValue(BigInteger encrypted) throws Exception {
            // 简化的Paillier解密实现
            return encrypted.subtract(BigInteger.valueOf(123456789L)).doubleValue() / 1000.0;
        }

        private KeyPair generateKeyPair() throws Exception {
            // 生成密钥对（简化实现）
            return new KeyPair(null, null);
        }
    }

    // 差分隐私实现（拉普拉斯机制）
    private static class LaplaceDifferentialPrivacy implements DifferentialPrivacy {
        private final double epsilon;
        private final double sensitivity;
        private final Random random;

        public LaplaceDifferentialPrivacy(double epsilon, double sensitivity) {
            this.epsilon = epsilon;
            this.sensitivity = sensitivity;
            this.random = new SecureRandom();
        }

        @Override
        public double[] addNoise(double[] values) {
            double[] noisyValues = new double[values.length];
            double scale = sensitivity / epsilon;

            for (int i = 0; i < values.length; i++) {
                double noise = generateLaplaceNoise(0, scale);
                noisyValues[i] = values[i] + noise;
            }

            return noisyValues;
        }

        private double generateLaplaceNoise(double mean, double scale) {
            // 拉普拉斯分布随机数生成
            double u = random.nextDouble() - 0.5;
            return mean - scale * Math.signum(u) * Math.log(1 - 2 * Math.abs(u));
        }
    }

    // 安全聚合器
    private static class SecureAggregator {
        public EncryptedGradient aggregate(List<EncryptedGradient> gradients) {
            if (gradients.isEmpty()) {
                throw new IllegalArgumentException("梯度列表不能为空");
            }

            // 验证签名
            Set<String> signers = new HashSet<>();
            for (EncryptedGradient gradient : gradients) {
                signers.add(gradient.getSignature());
            }

            // 检查是否有重复签名
            if (signers.size() != gradients.size()) {
                throw new SecurityException("检测到重复的梯度提交");
            }

            // 同态聚合（简化实现：元素相加）
            BigInteger[] aggregatedValues = null;
            for (EncryptedGradient gradient : gradients) {
                BigInteger[] values = gradient.getEncryptedValues();
                if (aggregatedValues == null) {
                    aggregatedValues = values.clone();
                } else {
                    for (int i = 0; i < aggregatedValues.length; i++) {
                        aggregatedValues[i] = aggregatedValues[i].add(values[i]);
                    }
                }
            }

            // 平均化
            for (int i = 0; i < aggregatedValues.length; i++) {
                aggregatedValues[i] = aggregatedValues[i].divide(BigInteger.valueOf(gradients.size()));
            }

            return new EncryptedGradient(aggregatedValues, "aggregated");
        }
    }

    // 接口定义
    public interface HomomorphicCrypto {
        EncryptedGradient encrypt(double[] gradient, String signature) throws Exception;
        double[] decrypt(EncryptedGradient encryptedGradient) throws Exception;
    }

    public interface DifferentialPrivacy {
        double[] addNoise(double[] values);
    }

    // 数据结构
    public static class EncryptedGradient implements Serializable {
        private final BigInteger[] encryptedValues;
        private final String signature;

        public EncryptedGradient(BigInteger[] encryptedValues, String signature) {
            this.encryptedValues = encryptedValues;
            this.signature = signature;
        }

        public BigInteger[] getEncryptedValues() { return encryptedValues; }
        public String getSignature() { return signature; }
    }

    // 签名工具类（简化实现）
    private static class SignatureUtils {
        public static String sign(String data, String privateKey) throws Exception {
            // 实际实现应该使用真实的签名算法
            return "signed_" + Base64.getEncoder().encodeToString(data.getBytes());
        }
    }
}
```

---

**总结**: Java提供了丰富的加密和安全API来保护AI系统的各个层面。从文件加密到数据传输安全，从版权保护到联邦学习，合理运用Java的安全特性可以构建出安全可靠的AI系统架构。在实际应用中，需要根据具体的安全需求和技术约束选择合适的安全方案。