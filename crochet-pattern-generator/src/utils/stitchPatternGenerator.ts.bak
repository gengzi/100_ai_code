import { YarnColor, StitchType, StitchDetail, ColorCell } from '../types';
import { CROCHET_SYMBOLS } from './crochetSymbols';
import { ImageAnalysisResult, TextureRegion, EdgePoint, StitchRecommendation } from './imageAnalyzer';

// é’ˆæ³•æ¨¡å¼å®šä¹‰
export interface StitchPattern {
  type: StitchType;
  probability: number;  // ä½¿ç”¨æ¦‚ç‡
  reason: string;       // ä½¿ç”¨åŸå› 
  confidence: number;   // æ¨èç½®ä¿¡åº¦
}

// åŒºåŸŸé’ˆæ³•åˆ†é…
export interface RegionStitchAssignment {
  x: number;
  y: number;
  width: number;
  height: number;
  stitchType: StitchType;
  reason: string;
  complexity: 'simple' | 'moderate' | 'complex';
}

export class StitchPatternGenerator {
  private complexityWeight: { [key: string]: number } = {
    'simple': 0.3,
    'moderate': 0.5,
    'complex': 0.8
  };

  /**
   * ç”Ÿæˆæ™ºèƒ½é’ˆæ³•æ¨¡å¼
   */
  generateStitchPattern(
    analysisResult: ImageAnalysisResult,
    width: number,
    height: number,
    colors: YarnColor[],
    difficulty: 'easy' | 'medium' | 'hard'
  ): {
    grid: (ColorCell | null)[][];
    patternMap: Map<string, StitchType>;
    explanations: string[];
    stitchDistribution: { [key: string]: number };
  } {
    // 1. æ ¹æ®å›¾åƒç‰¹å¾åˆ›å»ºé’ˆæ³•åˆ†é…
    const assignments = this.createRegionStitchAssignments(analysisResult, difficulty);

    // 2. ç”Ÿæˆé’ˆæ³•ç½‘æ ¼
    const { grid, patternMap } = this.createStitchGrid(
      assignments,
      analysisResult,
      width,
      height,
      colors
    );

    // 3. ç”Ÿæˆè¯´æ˜
    const explanations = this.generatePatternExplanations(assignments, difficulty);

    // 4. ç»Ÿè®¡é’ˆæ³•åˆ†å¸ƒ
    const stitchDistribution = this.calculateStitchDistribution(patternMap);

    return {
      grid,
      patternMap,
      explanations,
      stitchDistribution
    };
  }

  /**
   * åˆ›å»ºåŒºåŸŸé’ˆæ³•åˆ†é…
   */
  private createRegionStitchAssignments(
    analysisResult: ImageAnalysisResult,
    difficulty: 'easy' | 'medium' | 'hard'
  ): RegionStitchAssignment[] {
    const assignments: RegionStitchAssignment[] = [];

    // 1. åŸºäºçº¹ç†åŒºåŸŸçš„åŸºç¡€åˆ†é…
    analysisResult.textureRegions.forEach(region => {
      const stitchType = this.selectStitchForTexture(
        region.textureType,
        region.complexity,
        difficulty
      );

      assignments.push({
        x: region.x,
        y: region.y,
        width: region.width,
        height: region.height,
        stitchType,
        reason: `${region.textureType}çº¹ç†åŒºåŸŸï¼š${this.getStitchReason(region.textureType, stitchType)}`,
        complexity: this.mapComplexity(region.complexity)
      });
    });

    // 2. åŸºäºè¾¹ç¼˜çš„ç‰¹æ®Šå¤„ç†
    this.processEdgeRegions(analysisResult.edges, assignments, difficulty);

    // 3. åŸºäºæ•´ä½“å½¢çŠ¶å¤æ‚åº¦çš„è°ƒæ•´
    this.adjustForOverallComplexity(analysisResult.shapeComplexity, assignments, difficulty);

    // 4. åº”ç”¨éš¾åº¦é™åˆ¶
    this.applyDifficultyConstraints(assignments, difficulty);

    return assignments;
  }

  /**
   * æ ¹æ®çº¹ç†é€‰æ‹©é’ˆæ³•
   */
  private selectStitchForTexture(
    textureType: string,
    complexity: number,
    difficulty: 'easy' | 'medium' | 'hard'
  ): StitchType {
    const baseStitches = {
      easy: ['single', 'double', 'half-double', 'chain'],
      medium: ['single', 'double', 'half-double', 'treble', 'shell', 'increase', 'decrease'],
      hard: ['single', 'double', 'half-double', 'treble', 'shell', 'popcorn', 'bobble', 'increase', 'decrease', '2-together', 'front-post', 'back-post']
    }[difficulty] as StitchType[];

    const textureMapping = {
      flat: complexity < 0.2 ? 'single' : 'double',
      gradient: complexity < 0.4 ? 'half-double' : 'double',
      detailed: complexity < 0.6 ? 'double' : 'treble',
      textured: 'shell'
    };

    const suggestedStitch = textureMapping[textureType] as StitchType;

    // ç¡®ä¿é€‰æ‹©çš„é’ˆæ³•åœ¨éš¾åº¦èŒƒå›´å†…
    if (baseStitches.includes(suggestedStitch)) {
      return suggestedStitch;
    }

    // å›é€€åˆ°å®‰å…¨é€‰é¡¹
    return difficulty === 'easy' ? 'single' : 'double';
  }

  /**
   * è·å–é’ˆæ³•ä½¿ç”¨åŸå› 
   */
  private getStitchReason(textureType: string, stitchType: StitchType): string {
    const reasons = {
      'single-flat': 'å¹³æ»‘åŒºåŸŸæœ€é€‚åˆçŸ­é’ˆï¼Œèƒ½ä¿æŒç®€æ´çš„è¡¨é¢',
      'double-flat': 'å¹³å¦åŒºåŸŸä½¿ç”¨é•¿é’ˆå¯ä»¥æé«˜ç¼–ç»‡é€Ÿåº¦',
      'half-double-gradient': 'æ¸å˜åŒºåŸŸç”¨ä¸­é•¿é’ˆèƒ½åˆ›é€ è‡ªç„¶çš„è¿‡æ¸¡æ•ˆæœ',
      'double-gradient': 'æ¸å˜åŒºåŸŸç”¨é•¿é’ˆèƒ½å¢å¼ºè‰²å½©å±‚æ¬¡æ„Ÿ',
      'treble-detailed': 'ç»†èŠ‚åŒºåŸŸç”¨é•¿é•¿é’ˆèƒ½æ›´å¥½åœ°è¡¨ç°ç²¾ç»†å†…å®¹',
      'shell-textured': 'çº¹ç†åŒºåŸŸç”¨è´å£³é’ˆèƒ½åˆ›é€ ç«‹ä½“è£…é¥°æ•ˆæœ',
      'decrease-edge': 'è¾¹ç¼˜åŒºåŸŸä½¿ç”¨å‡é’ˆèƒ½å¡‘é€ æ¸…æ™°çš„è½®å»“',
      'increase-edge': 'è¾¹ç¼˜åŒºåŸŸä½¿ç”¨åŠ é’ˆèƒ½åˆ›é€ è‡ªç„¶çš„æ‰©å¼ æ•ˆæœ',
      'bobble-textured': 'é«˜çº¹ç†åŒºåŸŸç”¨æ³¡æ³¡é’ˆèƒ½å¢å¼ºç«‹ä½“æ„Ÿ',
      'popcorn-textured': 'å¤æ‚çº¹ç†åŒºåŸŸç”¨çˆ†ç±³èŠ±é’ˆèƒ½çªå‡ºè£…é¥°ç»†èŠ‚'
    };

    const key = `${stitchType}-${textureType}`;
    return reasons[key] || `æ ¹æ®${textureType}çº¹ç†ç‰¹å¾æ¨èä½¿ç”¨${stitchType}`;
  }

  /**
   * æ˜ å°„å¤æ‚åº¦
   */
  private mapComplexity(complexity: number): 'simple' | 'moderate' | 'complex' {
    if (complexity < 0.3) return 'simple';
    if (complexity < 0.7) return 'moderate';
    return 'complex';
  }

  /**
   * å¤„ç†è¾¹ç¼˜åŒºåŸŸ
   */
  private processEdgeRegions(
    edges: EdgePoint[],
    assignments: RegionStitchAssignment[],
    difficulty: 'easy' | 'medium' | 'hard'
  ): void {
    const edgeRegions = this.groupEdgesIntoRegions(edges);

    edgeRegions.forEach(region => {
      const stitchType = this.selectEdgeStitch(region.edgeStrength, difficulty);

      assignments.push({
        x: region.x,
        y: region.y,
        width: region.width,
        height: region.height,
        stitchType,
        reason: `è¾¹ç¼˜åŒºåŸŸï¼ˆå¼ºåº¦ï¼š${region.edgeStrength.toFixed(2)}ï¼‰ï¼š${this.getEdgeStitchReason(stitchType)}`,
        complexity: 'moderate'
      });
    });
  }

  /**
   * å°†è¾¹ç¼˜åˆ†ç»„ä¸ºåŒºåŸŸ
   */
  private groupEdgesIntoRegions(edges: EdgePoint[]): Array<{
    x: number;
    y: number;
    width: number;
    height: number;
    edgeStrength: number;
  }> {
    const regions: Array<{
      x: number;
      y: number;
      width: number;
      height: number;
      edgeStrength: number;
    }> = [];

    // ç®€å•çš„ç½‘æ ¼èšç±»ç®—æ³•
    const gridSize = 16;
    const gridMap = new Map<string, EdgePoint[]>();

    edges.forEach(edge => {
      const gridX = Math.floor(edge.x / gridSize);
      const gridY = Math.floor(edge.y / gridSize);
      const key = `${gridX},${gridY}`;

      if (!gridMap.has(key)) {
        gridMap.set(key, []);
      }
      gridMap.get(key)!.push(edge);
    });

    // è½¬æ¢ä¸ºåŒºåŸŸ
    gridMap.forEach((edgePoints, key) => {
      if (edgePoints.length >= 3) { // è‡³å°‘3ä¸ªç‚¹æ‰å½¢æˆåŒºåŸŸ
        const [gridX, gridY] = key.split(',').map(Number);
        const avgStrength = edgePoints.reduce((sum, e) => sum + e.edgeStrength, 0) / edgePoints.length;

        regions.push({
          x: gridX * gridSize,
          y: gridY * gridSize,
          width: gridSize,
          height: gridSize,
          edgeStrength: avgStrength
        });
      }
    });

    return regions;
  }

  /**
   * é€‰æ‹©è¾¹ç¼˜é’ˆæ³•
   */
  private selectEdgeStitch(
    edgeStrength: number,
    difficulty: 'easy' | 'medium' | 'hard'
  ): StitchType {
    if (difficulty === 'easy') {
      return edgeStrength > 0.7 ? 'decrease' : 'single';
    } else if (difficulty === 'medium') {
      return edgeStrength > 0.8 ? '2-together' : edgeStrength > 0.5 ? 'decrease' : 'double';
    } else {
      if (edgeStrength > 0.9) return '3-together';
      if (edgeStrength > 0.7) return '2-together';
      if (edgeStrength > 0.5) return 'decrease';
      return 'front-post';
    }
  }

  /**
   * è·å–è¾¹ç¼˜é’ˆæ³•åŸå› 
   */
  private getEdgeStitchReason(stitchType: StitchType): string {
    const reasons = {
      single: 'è¾¹ç¼˜ä½¿ç”¨çŸ­é’ˆä¿æŒç¨³å®š',
      double: 'è¾¹ç¼˜ä½¿ç”¨é•¿é’ˆå¢åŠ ç»“æ„æ€§',
      decrease: 'è¾¹ç¼˜ä½¿ç”¨å‡é’ˆå¡‘é€ è½®å»“',
      '2-together': 'å¼ºè¾¹ç¼˜ä½¿ç”¨2é’ˆå¹¶1é’ˆå¼ºåŒ–å½¢çŠ¶',
      '3-together': 'æå¼ºè¾¹ç¼˜ä½¿ç”¨3é’ˆå¹¶1é’ˆåˆ›é€ é”åˆ©è¾¹ç¼˜',
      'front-post': 'è¾¹ç¼˜ä½¿ç”¨å‰å¼•é•¿é’ˆåˆ›é€ ç«‹ä½“çº¹ç†'
    };

    return reasons[stitchType] || 'è¾¹ç¼˜åŒºåŸŸç‰¹æ®Šå¤„ç†';
  }

  /**
   * æ ¹æ®æ•´ä½“å¤æ‚åº¦è°ƒæ•´
   */
  private adjustForOverallComplexity(
    shapeComplexity: 'simple' | 'moderate' | 'complex',
    assignments: RegionStitchAssignment[],
    difficulty: 'easy' | 'medium' | 'hard'
  ): void {
    const complexityFactors = {
      simple: 0.8,  // ç®€å•å½¢çŠ¶é™ä½å¤æ‚åº¦
      moderate: 1.0, // ä¸­ç­‰ä¿æŒåŸæ ·
      complex: 1.2   // å¤æ‚å½¢çŠ¶å¢åŠ å¤æ‚åº¦
    }[shapeComplexity];

    // è°ƒæ•´ç°æœ‰åˆ†é…çš„å¤æ‚åº¦
    assignments.forEach(assignment => {
      const randomFactor = Math.random();
      if (randomFactor < 0.2 * complexityFactors) {
        // 20%çš„æ¦‚ç‡å¢åŠ å¤æ‚åº¦
        assignment.complexity = this.increaseComplexity(assignment.complexity);
      }
    });
  }

  /**
   * å¢åŠ å¤æ‚åº¦
   */
  private increaseComplexity(current: 'simple' | 'moderate' | 'complex'): 'simple' | 'moderate' | 'complex' {
    if (current === 'simple') return 'moderate';
    if (current === 'moderate') return 'complex';
    return 'complex';
  }

  /**
   * åº”ç”¨éš¾åº¦é™åˆ¶
   */
  private applyDifficultyConstraints(
    assignments: RegionStitchAssignment[],
    difficulty: 'easy' | 'medium' | 'hard'
  ): void {
    const allowedStitches = {
      easy: ['single', 'double', 'chain'],
      medium: ['single', 'double', 'half-double', 'treble', 'shell', 'increase', 'decrease'],
      hard: undefined // å…è®¸æ‰€æœ‰é’ˆæ³•
    }[difficulty] as StitchType[] | undefined;

    if (allowedStitches) {
      assignments.forEach(assignment => {
        if (!allowedStitches.includes(assignment.stitchType)) {
          // æ›¿æ¢ä¸ºå…è®¸çš„é’ˆæ³•
          assignment.stitchType = this.findClosestAllowedStitch(
            assignment.stitchType,
            allowedStitches,
            assignment.complexity
          );
        }
      });
    }
  }

  /**
   * æ‰¾åˆ°æœ€æ¥è¿‘çš„å…è®¸é’ˆæ³•
   */
  private findClosestAllowedStitch(
    originalStitch: StitchType,
    allowedStitches: StitchType[],
    complexity: 'simple' | 'moderate' | 'complex'
  ): StitchType {
    // å®šä¹‰é’ˆæ³•ç›¸ä¼¼æ€§æ˜ å°„
    const similarityMap = {
      'treble': 'double',
      'double-treble': 'double',
      'half-double': 'double',
      'shell': 'double',
      'popcorn': 'shell',
      'bobble': 'shell',
      'front-post': 'double',
      'back-post': 'double',
      'increase': 'single',
      'decrease': 'single',
      '2-together': 'decrease',
      '3-together': 'decrease',
      'slip': 'single',
      'chain': 'single'
    };

    const suggested = similarityMap[originalStitch] as StitchType;
    if (suggested && allowedStitches.includes(suggested)) {
      return suggested;
    }

    // å›é€€åˆ°åŸºäºå¤æ‚åº¦çš„é€‰æ‹©
    if (complexity === 'simple') return 'single';
    if (complexity === 'moderate' && allowedStitches.includes('double')) return 'double';
    return allowedStitches[0];
  }

  /**
   * åˆ›å»ºé’ˆæ³•ç½‘æ ¼
   */
  private createStitchGrid(
    assignments: RegionStitchAssignment[],
    analysisResult: ImageAnalysisResult,
    width: number,
    height: number,
    colors: YarnColor[]
  ): {
    grid: (ColorCell | null)[][];
    patternMap: Map<string, StitchType>;
  } {
    const grid: (ColorCell | null)[][] = [];
    const patternMap = new Map<string, StitchType>();

    // åˆå§‹åŒ–ç½‘æ ¼
    for (let y = 0; y < height; y++) {
      grid[y] = [];
      for (let x = 0; x < width; x++) {
        grid[y][x] = null;
      }
    }

    // æ ¹æ®åˆ†é…å¡«å……ç½‘æ ¼
    assignments.forEach(assignment => {
      for (let y = assignment.y; y < Math.min(assignment.y + assignment.height, height); y++) {
        for (let x = assignment.x; x < Math.min(assignment.x + assignment.width, width); x++) {
          if (x < width && y < height) {
            // ä»æå–çš„ä¸»ä½“å›¾åƒä¸­è·å–é¢œè‰²
            const imageData = analysisResult.extractedSubject;
            if (x < imageData.width && y < imageData.height) {
              const i = (y * imageData.width + x) * 4;
              if (imageData.data[i + 3] > 0) { // åªå¤„ç†ä¸é€æ˜åƒç´ 
                // æ‰¾åˆ°æœ€æ¥è¿‘çš„é¢œè‰²
                const pixelColor = {
                  r: imageData.data[i],
                  g: imageData.data[i + 1],
                  b: imageData.data[i + 2]
                };

                const closestColor = this.findClosestColor(pixelColor, colors);

                grid[y][x] = {
                  x,
                  y,
                  color: closestColor,
                  stitchType: assignment.stitchType
                };

                patternMap.set(`${x},${y}`, assignment.stitchType);
              }
            }
          }
        }
      }
    });

    return { grid, patternMap };
  }

  /**
   * æ‰¾åˆ°æœ€æ¥è¿‘çš„é¢œè‰²
   */
  private findClosestColor(
    pixelColor: { r: number; g: number; b: number },
    colors: YarnColor[]
  ): YarnColor {
    let minDistance = Infinity;
    let closestColor = colors[0];

    colors.forEach(color => {
      const distance = Math.sqrt(
        Math.pow(pixelColor.r - color.rgb.r, 2) +
        Math.pow(pixelColor.g - color.rgb.g, 2) +
        Math.pow(pixelColor.b - color.rgb.b, 2)
      );

      if (distance < minDistance) {
        minDistance = distance;
        closestColor = color;
      }
    });

    return closestColor;
  }

  /**
   * ç”Ÿæˆæ¨¡å¼è¯´æ˜
   */
  private generatePatternExplanations(
    assignments: RegionStitchAssignment[],
    difficulty: 'easy' | 'medium' | 'hard'
  ): string[] {
    const explanations: string[] = [];

    explanations.push(`ğŸ¨ æ™ºèƒ½é’ˆæ³•åˆ†é…è¯´æ˜ (${difficulty === 'easy' ? 'ç®€å•' : difficulty === 'medium' ? 'ä¸­ç­‰' : 'å›°éš¾'}éš¾åº¦)`);
    explanations.push('â•'.repeat(50));

    // æŒ‰é’ˆæ³•ç±»å‹åˆ†ç»„
    const stitchGroups = new Map<StitchType, RegionStitchAssignment[]>();
    assignments.forEach(assignment => {
      if (!stitchGroups.has(assignment.stitchType)) {
        stitchGroups.set(assignment.stitchType, []);
      }
      stitchGroups.get(assignment.stitchType)!.push(assignment);
    });

    // ç”Ÿæˆæ¯ç§é’ˆæ³•çš„è¯´æ˜
    stitchGroups.forEach((regions, stitchType) => {
      const symbol = CROCHET_SYMBOLS[stitchType];
      const totalArea = regions.reduce((sum, r) => sum + (r.width * r.height), 0);

      explanations.push(`\nğŸ”¸ ${symbol.chineseName} (${symbol.abbreviation})`);
      explanations.push(`   ç¬¦å·: ${symbol.symbol} | å æ¯”: ${((totalArea / (assignments.reduce((sum, r) => sum + (r.width * r.height), 0))) * 100).toFixed(1)}%`);
      explanations.push(`   åŸå› : ${regions[0].reason}`);

      if (regions.length > 1) {
        explanations.push(`   ä½¿ç”¨åŒºåŸŸ: ${regions.length}ä¸ªåŒºåŸŸ`);
      }
    });

    explanations.push('\nğŸ’¡ æ•´ä½“å»ºè®®');
    explanations.push('â”€'.repeat(30));
    explanations.push('â€¢ è¾¹ç¼˜åŒºåŸŸç‰¹åˆ«æ³¨æ„é’ˆæ³•å˜åŒ–ï¼Œç¡®ä¿è½®å»“æ¸…æ™°');
    explanations.push('â€¢ çº¹ç†ä¸°å¯Œçš„åŒºåŸŸå¯ä»¥é€‚å½“å¢åŠ è£…é¥°é’ˆæ³•');
    explanations.push('â€¢ ä¿æŒæ•´ä½“é£æ ¼çš„åè°ƒæ€§å’Œä¸€è‡´æ€§');

    return explanations;
  }

  /**
   * è®¡ç®—é’ˆæ³•åˆ†å¸ƒ
   */
  private calculateStitchDistribution(patternMap: Map<string, StitchType>): { [key: string]: number } {
    const distribution: { [key: string]: number } = {};

    patternMap.forEach(stitchType => {
      distribution[stitchType] = (distribution[stitchType] || 0) + 1;
    });

    return distribution;
  }
}

export const stitchPatternGenerator = new StitchPatternGenerator();